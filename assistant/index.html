<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Synapse</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
<style>
:root {
  --bg: #0a0a0f;
  --sidebar-bg: #14141a;
  --card-border: rgba(255, 255, 255, 0.08);
  --text-primary: rgba(255, 255, 255, 0.95);
  --text-secondary: rgba(255, 255, 255, 0.6);
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --msg-user: #6366f1;
  --msg-assistant: rgba(255, 255, 255, 0.08);
  --hover: rgba(255, 255, 255, 0.05);
  --accent-text: white;
  --msg-user-text: white;
  --overlay-10: rgba(255, 255, 255, 0.1);
  --overlay-15: rgba(255, 255, 255, 0.15);
  --overlay-25: rgba(255, 255, 255, 0.25);
  --border-radius: 16px;
  --msg-max-width: 75%;
  --msg-padding: 12px 16px;
  --msg-font-size: 0.95em;
  --code-bg: rgba(0,0,0,0.3);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  height: 100vh;
  height: 100dvh;
  background: var(--bg);
  color: var(--text-primary);
  display: flex;
  overflow: hidden;
}

/* Sidebar */
.sidebar {
  width: 260px;
  background: var(--sidebar-bg);
  border-right: 1px solid var(--card-border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  transition: margin-left 0.3s ease;
}
.sidebar.collapsed { margin-left: -260px; }

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--card-border);
  display: flex;
  gap: 8px;
}
.sidebar-header button {
  flex: 1;
  padding: 10px;
  font-family: inherit;
  font-size: 0.85em;
  font-weight: 600;
  background: var(--accent);
  color: var(--accent-text);
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}
.sidebar-header button:hover { background: var(--accent-hover); }

.sidebar-search {
  padding: 8px 8px 0;
  position: relative;
}
.sidebar-search input {
  width: 100%;
  padding: 8px 28px 8px 10px;
  font-family: inherit;
  font-size: 0.82em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 6px;
  color: var(--text-primary);
  outline: none;
  transition: border-color 0.2s;
}
.sidebar-search input:focus { border-color: var(--accent); }
.sidebar-search input::placeholder { color: var(--text-secondary); }
.search-clear-btn {
  position: absolute; right: 18px; top: 50%; transform: translateY(-50%);
  background: none; border: none; color: var(--text-secondary); cursor: pointer;
  font-size: 16px; padding: 4px; display: none;
}
.sidebar-search input:not(:placeholder-shown) + .search-clear-btn { display: block; }

.conv-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.conv-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85em;
  color: var(--text-secondary);
  transition: all 0.2s;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px;
}
.conv-item:hover { background: var(--hover); }
.conv-item.active { background: rgba(99, 102, 241, 0.15); color: var(--text-primary); }

.conv-item .conv-title {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.conv-rename-input {
  background: var(--bg);
  color: var(--text-primary);
  border: 1px solid var(--accent);
  border-radius: 4px;
  padding: 2px 4px;
  font-size: inherit;
  width: 100%;
  flex: 1;
  outline: none;
}
.conv-item .conv-delete {
  display: none;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  padding: 0 4px;
  flex-shrink: 0;
}
.conv-item:hover .conv-delete { display: block; }
.conv-item .conv-delete:hover { color: #ef4444; }

/* Main Area */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  position: relative;
}

/* Header Toolbar */
.toolbar {
  height: 50px;
  padding: 0 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--card-border);
  background: var(--sidebar-bg);
  flex-shrink: 0;
}
.toolbar-left { display: flex; align-items: center; gap: 12px; }
.toolbar-toggle {
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 18px;
  cursor: pointer;
  padding: 4px;
}
.toolbar-title {
  font-size: 0.95em;
  font-weight: 600;
}
.toolbar-right { display: flex; align-items: center; gap: 8px; }
.toolbar-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  padding: 6px;
  border-radius: 6px;
  transition: all 0.2s;
  position: relative;
}
.toolbar-btn:hover { color: var(--text-primary); background: var(--hover); }

/* Toolbar more menu */
.toolbar-more {
  position: relative;
}
.toolbar-menu {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 4px;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  min-width: 180px;
  z-index: 100;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  overflow: hidden;
}
.toolbar-menu.open { display: block; }
.toolbar-menu button {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 14px;
  font-family: inherit;
  font-size: 0.85em;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  text-align: left;
}
.toolbar-menu button:hover { background: var(--hover); color: var(--text-primary); }

.theme-flash {
  position: absolute;
  bottom: -22px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.7em;
  white-space: nowrap;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  padding: 2px 6px;
  border-radius: 4px;
  pointer-events: none;
  animation: flashFade 1.5s ease forwards;
  z-index: 10;
}
@keyframes flashFade { 0% { opacity: 1; } 70% { opacity: 1; } 100% { opacity: 0; } }

/* Messages Area */
.messages-area {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.chat-placeholder {
  color: var(--text-secondary);
  font-size: 1em;
  text-align: center;
  padding: 60px 20px;
  margin: auto;
}

/* Message styles */
.msg-wrapper { display: flex; flex-direction: column; position: relative; }
.msg-wrapper.user { align-self: flex-end; max-width: var(--msg-max-width); }
.msg-wrapper.assistant { align-self: flex-start; max-width: var(--msg-max-width); }
.msg-wrapper.assistant.has-avatar { flex-direction: row; align-items: flex-start; }
.msg-avatar { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-right: 8px; margin-top: 2px; }

.msg-bubble {
  padding: var(--msg-padding);
  border-radius: var(--border-radius);
  font-size: var(--msg-font-size);
  line-height: 1.6;
  word-wrap: break-word;
}
.msg-bubble.user {
  background: var(--msg-user);
  color: var(--msg-user-text);
  border-bottom-right-radius: 4px;
  white-space: pre-wrap;
}
.msg-bubble.assistant {
  background: var(--msg-assistant);
  color: var(--text-primary);
  border-bottom-left-radius: 4px;
}

/* Markdown in messages */
.msg-bubble pre { background: var(--code-bg); padding: 10px; border-radius: 8px; overflow-x: auto; margin: 6px 0; white-space: pre; }
.msg-bubble code { background: var(--overlay-10); padding: 2px 5px; border-radius: 4px; font-family: 'Menlo', 'Monaco', 'Consolas', monospace; font-size: 0.9em; }
.msg-bubble pre code { background: none; padding: 0; }
.msg-bubble blockquote { border-left: 3px solid var(--accent); padding-left: 10px; color: var(--text-secondary); margin: 6px 0; }
.msg-bubble a { color: var(--accent-hover); text-decoration: underline; }
.msg-bubble ul, .msg-bubble ol { padding-left: 20px; margin: 4px 0; }
.msg-bubble h1, .msg-bubble h2, .msg-bubble h3, .msg-bubble h4 { margin: 8px 0 4px; font-weight: 600; }
.msg-bubble h1 { font-size: 1.2em; }
.msg-bubble h2 { font-size: 1.1em; }
.msg-bubble h3 { font-size: 1.05em; }
.msg-bubble table { border-collapse: collapse; margin: 6px 0; font-size: 0.95em; }
.msg-bubble th, .msg-bubble td { border: 1px solid var(--card-border); padding: 4px 8px; }
.msg-bubble th { background: var(--hover); }
.msg-bubble img.chat-inline-img { max-width: min(300px, 100%); max-height: 300px; border-radius: 8px; margin-top: 6px; display: block; }
.chat-file-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px; border-radius: 6px; background: var(--card-bg); border: 1px solid var(--card-border); font-size: 0.82em; color: var(--text-secondary); text-decoration: none; margin-top: 6px; cursor: pointer; }
.chat-file-badge:hover { background: var(--card-border); }

/* Code copy button */
.code-block-wrapper { position: relative; }
.code-copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: var(--overlay-15);
  border: none;
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s, background 0.2s;
}
.code-block-wrapper:hover .code-copy-btn { opacity: 1; }
.code-copy-btn:hover { background: var(--overlay-25); color: var(--text-primary); }

/* Message actions */
.msg-actions {
  display: none;
  gap: 4px;
  margin-top: 4px;
}
.msg-wrapper:hover .msg-actions { display: flex; }
.msg-action-btn {
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.2s;
}
.msg-action-btn:hover { background: var(--overlay-10); color: var(--text-primary); }

/* Message edit mode */
.msg-edit-textarea {
  width: 100%;
  min-height: 60px;
  padding: 10px;
  font-family: inherit;
  font-size: 0.95em;
  background: var(--hover);
  border: 1px solid var(--accent);
  border-radius: 8px;
  color: var(--text-primary);
  resize: vertical;
  outline: none;
  margin-top: 8px;
  line-height: 1.5;
}
.msg-edit-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}
.msg-edit-actions button {
  padding: 6px 14px;
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s;
}
.msg-edit-save { background: var(--accent); color: var(--accent-text); }
.msg-edit-save:hover { background: var(--accent-hover); }
.msg-edit-cancel { background: var(--hover); color: var(--text-primary); border: 1px solid var(--card-border) !important; }
.msg-edit-cancel:hover { background: var(--overlay-10); }

/* Swipe controls */
.swipe-controls { display: none; flex-direction: row; align-items: center; gap: 8px; margin-top: 6px; font-size: 0.8em; color: var(--text-secondary); }
.msg-wrapper.assistant:last-child .swipe-controls.has-swipes { display: flex; }
.swipe-controls button { background: var(--hover); border: none; color: var(--text-secondary); padding: 3px 10px; border-radius: 6px; cursor: pointer; }
.swipe-controls button:hover { background: var(--overlay-10); color: var(--text-primary); }
.swipe-controls button:disabled { opacity: 0.3; cursor: not-allowed; }

/* Regenerate button */
.regen-btn { display: none; background: var(--hover); border: none; color: var(--text-secondary); padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.8em; margin-top: 6px; transition: all 0.2s; align-self: flex-start; font-family: inherit; }
.msg-wrapper.assistant:last-child .regen-btn { display: inline-block; }
.regen-btn:hover { background: var(--overlay-10); color: var(--text-primary); }

/* Input Footer */
.input-area {
  padding: 12px 16px 16px;
  border-top: 1px solid var(--card-border);
  background: var(--sidebar-bg);
}
.image-preview { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
.image-preview:empty { display: none; }
.img-thumb { position: relative; width: 56px; height: 56px; border-radius: 8px; overflow: hidden; flex-shrink: 0; }
.img-thumb img { width: 100%; height: 100%; object-fit: cover; }
.img-thumb .remove-thumb { position: absolute; top: -2px; right: -2px; background: #ef4444; border: none; color: white; width: 18px; height: 18px; border-radius: 50%; font-size: 11px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.file-thumb { position: relative; height: 56px; border-radius: 8px; padding: 0 12px; background: var(--card-bg); border: 1px solid var(--card-border); display: flex; align-items: center; font-size: 0.78em; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; flex-shrink: 0; }
.file-thumb .remove-thumb { position: absolute; top: -2px; right: -2px; background: #ef4444; border: none; color: white; width: 18px; height: 18px; border-radius: 50%; font-size: 11px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

.input-row { display: flex; gap: 8px; align-items: flex-end; }
.input-row textarea {
  flex: 1;
  padding: 10px 14px;
  font-size: 0.95em;
  font-family: inherit;
  background: var(--hover);
  border: 2px solid var(--card-border);
  border-radius: 12px;
  color: var(--text-primary);
  outline: none;
  resize: none;
  min-height: 44px;
  max-height: 150px;
  line-height: 1.4;
  transition: border-color 0.3s;
}
.input-row textarea:focus { border-color: var(--accent); }
.input-row textarea::placeholder { color: var(--text-secondary); }

.input-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 18px;
  cursor: pointer;
  padding: 8px;
  flex-shrink: 0;
  transition: color 0.2s;
}
.input-btn:hover { color: var(--text-primary); }
.input-btn.recording { color: #ef4444; animation: voicePulse 1s ease-in-out infinite; }
@keyframes voicePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

.send-btn {
  padding: 10px 20px;
  font-size: 0.9em;
  font-family: inherit;
  font-weight: 600;
  background: var(--accent);
  color: var(--accent-text);
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.send-btn:hover { background: var(--accent-hover); }
.send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
.send-btn.streaming { background: #ef4444; color: white; }
.send-btn.streaming:hover { background: #dc2626; }

.token-info { font-size: 0.75em; color: var(--text-secondary); text-align: right; margin-top: 6px; min-height: 1em; }

/* Modals */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(4px);
}
.modal-overlay.open { display: flex; }

.modal {
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: var(--border-radius);
  padding: 28px;
  width: 90%;
  max-width: 520px;
  max-height: 90vh;
  max-height: 90dvh;
  overflow-y: auto;
}
.modal h2 {
  font-size: 1.2em;
  margin-bottom: 20px;
}
.modal label {
  display: block;
  font-size: 0.85em;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.modal input, .modal textarea, .modal select {
  width: 100%;
  padding: 12px;
  font-family: inherit;
  font-size: 0.9em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  color: var(--text-primary);
  margin-bottom: 14px;
  outline: none;
  transition: border-color 0.2s;
}
.prompt-entry-header input,
.prompt-entry-header button,
.prompt-entry-body textarea {
  width: auto;
  padding: 0;
  margin-bottom: 0;
  font-size: inherit;
  background: none;
  border: none;
  border-radius: 0;
}
.modal input:focus, .modal textarea:focus, .modal select:focus { border-color: var(--accent); }
.modal textarea { resize: vertical; min-height: 60px; max-height: 120px; }
.modal select option { background: var(--sidebar-bg); color: var(--text-primary); }

.modal .modal-actions {
  display: flex;
  gap: 10px;
  margin-top: 8px;
}
.modal .btn {
  flex: 1;
  padding: 12px;
  font-family: inherit;
  font-size: 0.9em;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}
.modal .btn-primary { background: var(--accent); color: var(--accent-text); }
.modal .btn-primary:hover { background: var(--accent-hover); }
.modal .btn-secondary { background: var(--hover); color: var(--text-primary); }
.modal .btn-secondary:hover { background: var(--overlay-10); }

.modal .invalid { border-color: #ef4444 !important; }

/* Model selector row */
.model-selector-row {
  display: flex;
  gap: 8px;
  margin-bottom: 4px;
}
.model-selector-row select {
  flex: 1;
  margin-bottom: 0;
}
.model-refresh-btn {
  padding: 8px 12px;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  color: var(--text-primary);
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
  flex-shrink: 0;
}
.model-refresh-btn:hover { background: var(--overlay-10); }

/* Theme color pickers */
.theme-colors {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 14px;
}
.theme-color-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8em;
  color: var(--text-secondary);
}
.theme-color-item input[type="color"] {
  width: 32px;
  height: 28px;
  border: 1px solid var(--card-border);
  border-radius: 4px;
  background: none;
  cursor: pointer;
  padding: 0;
}

/* Section dividers in settings */
.modal-section {
  font-size: 0.8em;
  font-weight: 600;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 18px 0 10px;
  padding-bottom: 4px;
  border-bottom: 1px solid var(--card-border);
}
.modal-section:first-of-type { margin-top: 0; }

@media (hover: none) {
  .msg-wrapper .msg-actions { display: flex; }
  .code-block-wrapper .code-copy-btn { opacity: 1; }
  .code-block-wrapper .code-download-btn { opacity: 1; }
  .conv-item .conv-delete { display: block; }
}

/* Responsive */
@media (max-width: 768px) {
  .sidebar { position: fixed; left: 0; top: 0; bottom: 0; z-index: 500; }
  .sidebar.collapsed { margin-left: -260px; }
  .msg-wrapper.user, .msg-wrapper.assistant { max-width: 95% !important; }
  .msg-avatar { width: 26px; height: 26px; margin-right: 6px; }
  .toolbar-title { font-size: 0.85em; }
  .input-area { padding: 8px 12px 12px; }
  .messages-area { padding: 12px; }
  .sidebar-overlay.open { display: block; }
  .toolbar { padding-top: env(safe-area-inset-top); }
  .input-area { padding-bottom: max(12px, env(safe-area-inset-bottom)); }
  .sidebar { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
  .toolbar-btn { padding: 10px; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .toolbar-toggle { min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .input-btn { min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .img-thumb .remove-thumb { width: 28px; height: 28px; font-size: 14px; top: -4px; right: -4px; }
  .file-thumb .remove-thumb { width: 28px; height: 28px; font-size: 14px; top: -4px; right: -4px; }
  .msg-action-btn { padding: 8px 12px; font-size: 0.8em; min-height: 36px; }
  .swipe-controls button { padding: 8px 14px; min-height: 36px; }
  .regen-btn { padding: 10px 16px; min-height: 36px; }
  .code-copy-btn { padding: 8px 12px; font-size: 0.8em; min-height: 36px; }
  .conv-item .conv-delete { padding: 8px; min-width: 36px; min-height: 36px; display: flex; align-items: center; justify-content: center; }
  .input-row textarea, .modal input, .modal textarea, .modal select, .sidebar-search input, .chat-search-bar input, .msg-edit-textarea { font-size: 16px; }
}

/* Mobile sidebar overlay */
.sidebar-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  z-index: 499;
}

/* Tool use blocks (web search) */
.tool-use-block {
  margin-bottom: 8px;
  border-radius: 8px;
  background: var(--hover);
  overflow: hidden;
  font-size: 0.85em;
}
.tool-use-header {
  padding: 8px 12px;
  cursor: pointer;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 6px;
  user-select: none;
}
.tool-use-header:hover { color: var(--text-primary); }
.tool-use-results {
  display: none;
  padding: 4px 12px 8px;
  border-top: 1px solid var(--card-border);
}
.tool-use-results.open { display: block; }
.tool-use-result { margin: 4px 0; }
.tool-use-result a {
  color: var(--accent);
  text-decoration: none;
  font-size: 0.85em;
}
.tool-use-result a:hover { text-decoration: underline; }
.tool-use-result .tool-result-url {
  color: var(--text-secondary);
  font-size: 0.8em;
  display: block;
}

/* Settings toggle row */
.toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
  color: var(--text-primary);
  margin-bottom: 10px;
  cursor: pointer;
}
.toggle-row input[type="checkbox"] {
  width: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
}
.toggle-hint {
  color: var(--text-secondary);
  font-size: 0.8em;
  margin-left: auto;
}

/* Prompt entry list */
.prompt-entry-list { max-height: 340px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; margin-bottom: 8px; }
.prompt-entry { background: var(--hover); border-radius: 8px; overflow: hidden; transition: opacity 0.2s; border: 1px solid var(--card-border); flex-shrink: 0; }
.prompt-entry.disabled { opacity: 0.5; }
.prompt-entry.dragging { opacity: 0.4; }
.prompt-entry.drag-over { border-color: var(--accent); }
.prompt-entry-header { display: flex; align-items: center; gap: 10px; padding: 14px 16px; cursor: default; }
.prompt-entry-header .drag-handle { cursor: grab; color: var(--text-secondary); -webkit-text-fill-color: var(--text-secondary); user-select: none; font-size: 1.2em; flex-shrink: 0; }
.prompt-entry-header input[type="checkbox"] { width: 22px; height: 22px; margin: 0; cursor: pointer; flex-shrink: 0; padding: 0; }
.prompt-entry-header .pe-name { flex: 1; background: var(--sidebar-bg); border: 1px solid var(--card-border); color: var(--text-primary); -webkit-text-fill-color: var(--text-primary); font-size: 16px; font-family: inherit; padding: 10px 12px; border-radius: 6px; min-width: 0; }
.prompt-entry-header .pe-name:focus { border-color: var(--accent); outline: none; }
.prompt-entry-header button { background: none; border: none; color: var(--text-secondary); -webkit-text-fill-color: var(--text-secondary); cursor: pointer; font-size: 1.3em; padding: 8px; line-height: 1; flex-shrink: 0; min-width: 40px; min-height: 40px; display: flex; align-items: center; justify-content: center; }
.prompt-entry-header button:hover { color: var(--text-primary); -webkit-text-fill-color: var(--text-primary); }
.prompt-entry-body { display: none; padding: 0 14px 12px; }
.prompt-entry-body.open { display: block; }
.prompt-entry-body textarea { width: 100%; min-height: 100px; resize: vertical; font-size: 16px; background: var(--hover); border: 1px solid var(--card-border); border-radius: 6px; padding: 10px; color: var(--text-primary); }

/* Message fade-in animation */
@keyframes msgFadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
.msg-new { animation: msgFadeIn 0.3s ease forwards; }

/* Animated typing indicator */
.typing-dots { display: inline-flex; align-items: center; gap: 4px; padding: 4px 0; }
.typing-dots span { width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); animation: typingBounce 1.2s ease-in-out infinite; }
.typing-dots span:nth-child(2) { animation-delay: 0.15s; }
.typing-dots span:nth-child(3) { animation-delay: 0.3s; }
@keyframes typingBounce { 0%, 60%, 100% { transform: translateY(0); opacity: 0.4; } 30% { transform: translateY(-6px); opacity: 1; } }

/* Scroll-to-bottom FAB */
.scroll-fab {
  position: absolute;
  bottom: 12px;
  right: 20px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--accent);
  color: var(--accent-text);
  border: none;
  cursor: pointer;
  font-size: 18px;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transition: background 0.2s, transform 0.2s;
}
.scroll-fab:hover { background: var(--accent-hover); transform: scale(1.1); }
.scroll-fab.visible { display: flex; }

/* Toast notifications */
.toast-container { position: fixed; top: 16px; right: 16px; z-index: 2000; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
.toast {
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 0.85em;
  font-family: inherit;
  color: white;
  pointer-events: auto;
  animation: toastIn 0.3s ease forwards;
  max-width: 340px;
  word-break: break-word;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.toast.info { background: var(--accent); }
.toast.error { background: #ef4444; }
.toast.success { background: #22c55e; }
.toast.removing { animation: toastOut 0.3s ease forwards; }
@keyframes toastIn { from { opacity: 0; transform: translateX(40px); } to { opacity: 1; transform: translateX(0); } }
@keyframes toastOut { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(40px); } }

/* Thinking/reasoning blocks */
.thinking-block { margin-bottom: 8px; border-radius: 8px; background: var(--hover); overflow: hidden; font-size: 0.85em; }
.thinking-header { padding: 8px 12px; cursor: pointer; color: var(--text-secondary); display: flex; align-items: center; gap: 6px; user-select: none; }
.thinking-header:hover { color: var(--text-primary); }
.thinking-content { display: none; padding: 4px 12px 8px; border-top: 1px solid var(--card-border); white-space: pre-wrap; color: var(--text-secondary); max-height: 300px; overflow-y: auto; }
.thinking-content.open { display: block; }

/* Line numbers in code blocks */
.code-line { counter-increment: code-line; display: block; }
.code-line::before { content: counter(code-line); display: inline-block; width: 2.5em; margin-right: 0.8em; text-align: right; color: var(--text-secondary); opacity: 0.4; user-select: none; -webkit-user-select: none; font-size: 0.85em; }
pre.has-line-numbers { counter-reset: code-line; }

/* Code download button */
.code-download-btn {
  position: absolute;
  top: 6px;
  right: 56px;
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: var(--overlay-15);
  border: none;
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s, background 0.2s;
}
.code-block-wrapper:hover .code-download-btn { opacity: 1; }
.code-download-btn:hover { background: var(--overlay-25); color: var(--text-primary); }

/* Mermaid container */
.mermaid-container { margin: 6px 0; overflow-x: auto; }
.mermaid-container svg { max-width: 100%; }

/* Pin button on conversations */
.conv-pin { display: none; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0 4px; flex-shrink: 0; opacity: 0.6; }
.conv-item:hover .conv-pin { display: block; }
.conv-pin.pinned { display: block; opacity: 1; color: var(--accent); }
.conv-pin:hover { opacity: 1; }

/* Date group headers */
.conv-group-header { font-size: 0.7em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; padding: 10px 12px 4px; }

/* Drag-drop reorder */
.conv-item.dragging { opacity: 0.4; }
.conv-item.drag-over { border-top: 2px solid var(--accent); }

/* Branch controls */
.branch-controls { display: none; flex-direction: row; align-items: center; gap: 8px; margin-top: 6px; font-size: 0.8em; color: var(--text-secondary); }
.branch-controls.has-branches { display: flex; }
.branch-controls button { background: var(--hover); border: none; color: var(--text-secondary); padding: 3px 10px; border-radius: 6px; cursor: pointer; }
.branch-controls button:hover { background: var(--overlay-10); color: var(--text-primary); }
.branch-controls button:disabled { opacity: 0.3; cursor: not-allowed; }

/* Chat search bar */
.chat-search-bar {
  display: none;
  padding: 6px 16px;
  background: var(--sidebar-bg);
  border-bottom: 1px solid var(--card-border);
  gap: 8px;
  align-items: center;
}
.chat-search-bar.open { display: flex; }
.chat-search-bar input {
  flex: 1;
  padding: 6px 10px;
  font-family: inherit;
  font-size: 0.85em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 6px;
  color: var(--text-primary);
  outline: none;
}
.chat-search-bar input:focus { border-color: var(--accent); }
.chat-search-bar button {
  background: var(--hover);
  border: none;
  color: var(--text-secondary);
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85em;
}
.chat-search-bar button:hover { color: var(--text-primary); }
.chat-search-bar .search-count { font-size: 0.8em; color: var(--text-secondary); white-space: nowrap; }
.search-highlight { background: rgba(255, 200, 50, 0.3); border-radius: 2px; }
.search-highlight.active { background: rgba(255, 200, 50, 0.6); }

/* Spoiler tags */
.spoiler {
  background: var(--text-primary);
  color: transparent;
  border-radius: 4px;
  padding: 1px 4px;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}
.spoiler.revealed {
  background: var(--hover);
  color: var(--text-primary);
  user-select: auto;
}

/* @model mentions */
.model-override-badge {
  display: none;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  margin-bottom: 6px;
  font-size: 0.8em;
  background: var(--hover);
  border: 1px solid var(--accent);
  border-radius: 8px;
  color: var(--accent);
  width: fit-content;
}
.model-override-badge.visible { display: inline-flex; }
.model-override-badge button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  line-height: 1;
}
.model-override-badge button:hover { color: var(--text-primary); }
.mention-dropdown {
  position: absolute;
  bottom: 100%;
  left: 50px;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  max-height: 200px;
  overflow-y: auto;
  display: none;
  z-index: 100;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.mention-dropdown.open { display: block; }
.mention-item {
  padding: 8px 12px;
  font-size: 0.85em;
  cursor: pointer;
  color: var(--text-secondary);
}
.mention-item:hover, .mention-item.active { background: var(--hover); color: var(--text-primary); }

@media (hover: none) {
  .scroll-fab { width: 44px; height: 44px; }
  .conv-pin { display: block; }
  .branch-controls button { padding: 8px 14px; min-height: 36px; }
}

/* Character card avatar in sidebar */
.conv-avatar {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  margin-right: 4px;
}

/* Character info popup */
.char-info-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 16px;
  padding: 24px;
  max-width: 480px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1100;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}
.char-info-popup h3 { margin-bottom: 12px; }
.char-info-popup .char-info-field { margin-bottom: 10px; font-size: 0.85em; }
.char-info-popup .char-info-label { color: var(--accent); font-weight: 600; font-size: 0.8em; text-transform: uppercase; letter-spacing: 0.03em; margin-bottom: 2px; }
.char-info-popup .char-info-value { color: var(--text-secondary); white-space: pre-wrap; }
.char-info-popup .char-info-avatar { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-bottom: 12px; }
.char-info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1099;
}
@media (max-width: 768px) {
  .toast { max-width: calc(100vw - 32px); }
  .scroll-fab { width: 44px; height: 44px; bottom: 8px; right: 12px; }
}
/* Focus-visible for keyboard navigation */
button:focus-visible, input:focus-visible, textarea:focus-visible, select:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* Message timestamps */
.msg-timestamp {
  font-size: 0.75em;
  color: var(--text-secondary);
  margin-top: 4px;
}

</style>
</head>
<body>

<!-- Sidebar overlay for mobile -->
<div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

<!-- Toast container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <button onclick="createConversation()" aria-label="New chat">+ New Chat</button>
    <button onclick="document.getElementById('charImportInput').click()" title="Import character card" aria-label="Import character card" style="flex:0 0 auto;padding:10px 12px">&#128101;</button>
    <button onclick="clearAllConversations()" title="Delete all conversations" aria-label="Delete all conversations" style="flex:0 0 auto;padding:10px 12px">&#128465;</button>
    <input type="file" id="charImportInput" accept=".png,.json" style="display:none" onchange="importCharacterCard(event)">
  </div>
  <div class="sidebar-search">
    <input type="text" id="sidebarSearch" placeholder="Search conversations..." oninput="filterConversations()">
    <button class="search-clear-btn" onclick="document.getElementById('sidebarSearch').value='';filterConversations()" aria-label="Clear search">&times;</button>
  </div>
  <div class="conv-list" id="convList"></div>
</div>

<!-- Main Area -->
<div class="main">
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolbar-left">
      <button class="toolbar-toggle" onclick="toggleSidebar()" title="Toggle sidebar" aria-label="Toggle sidebar">&#9776;</button>
      <span class="toolbar-title">Synapse</span>
    </div>
    <div class="toolbar-right">
      <div class="toolbar-more">
        <button class="toolbar-btn" onclick="toggleToolbarMenu(event)" title="More actions" aria-label="More actions">&#8943;</button>
        <div class="toolbar-menu" id="toolbarMenu">
          <button onclick="exportConversation();closeToolbarMenu()">&#8615; Export chat (JSON)</button>
          <button onclick="exportMarkdown();closeToolbarMenu()">&#128221; Export as Markdown</button>
          <button onclick="exportAllConversations();closeToolbarMenu()">&#8659; Export all chats</button>
          <button onclick="document.getElementById('importInput').click();closeToolbarMenu()">&#8613; Import chat</button>
          <button onclick="clearChat();closeToolbarMenu()">&#128465; Clear chat</button>
        </div>
      </div>
      <input type="file" id="importInput" accept=".json" style="display:none" onchange="importConversation(event)">
      <button class="toolbar-btn" id="charInfoBtn" onclick="showCharacterInfo()" title="Character info" aria-label="Character info" style="display:none">&#8505;</button>
      <button class="toolbar-btn" onclick="openSettings()" title="Settings" aria-label="Settings">&#9881;</button>
      <button class="toolbar-btn" id="themeToggle" onclick="toggleTheme()" title="Theme: dark" aria-label="Toggle theme">&#9790;</button>
    </div>
  </div>

  <!-- Chat search bar -->
  <div class="chat-search-bar" id="chatSearchBar">
    <input type="text" id="chatSearchInput" placeholder="Search in chat..." oninput="debouncedChatSearch()">
    <span class="search-count" id="chatSearchCount"></span>
    <button onclick="navigateChatSearch(-1)" title="Previous" aria-label="Previous search result">&#9650;</button>
    <button onclick="navigateChatSearch(1)" title="Next" aria-label="Next search result">&#9660;</button>
    <button onclick="closeChatSearch()" title="Close" aria-label="Close search">&times;</button>
  </div>

  <!-- Messages -->
  <div class="messages-area" id="messagesArea">
    <div class="chat-placeholder">Start a conversation...</div>
  </div>
  <button class="scroll-fab" id="scrollFab" onclick="document.getElementById('messagesArea').scrollTo({top:document.getElementById('messagesArea').scrollHeight,behavior:'smooth'})" title="Scroll to bottom" aria-label="Scroll to bottom">&#8595;</button>

  <!-- Input -->
  <div class="input-area">
    <div class="image-preview" id="imagePreview"></div>
    <div class="model-override-badge" id="modelOverrideBadge">
      <span id="modelOverrideText"></span>
      <button onclick="clearModelOverride()" title="Clear override">&times;</button>
    </div>
    <div class="input-row" style="position:relative">
      <div class="mention-dropdown" id="mentionDropdown"></div>
      <button class="input-btn" onclick="document.getElementById('fileInput').click()" title="Attach file" aria-label="Attach file">&#128206;</button>
      <input type="file" id="fileInput" accept="image/*,.pdf,.txt,.csv,.html,.md" multiple style="display:none" onchange="handleFileSelect(event)">
      <textarea id="chatInput" placeholder="Type a message..." rows="1"></textarea>
      <button class="input-btn" id="voiceBtn" onclick="toggleVoice()" title="Voice input" aria-label="Voice input">&#127908;</button>
      <button class="send-btn" id="sendBtn" onclick="sendMessage()" aria-label="Send message">Send</button>
    </div>
    <div class="token-info" id="tokenInfo"></div>
  </div>
</div>

<!-- Setup Modal -->
<div class="modal-overlay" id="setupModal">
  <div class="modal">
    <h2>Welcome to Synapse</h2>
    <p style="color:var(--text-secondary);font-size:0.9em;margin-bottom:20px">Enter your API settings to get started. Your keys are stored locally and never sent to any server except your configured proxy.</p>
    <label>Base URL</label>
    <input type="text" id="setupProxy" placeholder="https://api.openai.com/v1">
    <label>API Key</label>
    <input type="password" id="setupKey" placeholder="sk-...">
    <label>Model</label>
    <div class="model-selector-row">
      <select id="setupModelSelect" onchange="document.getElementById('setupModelManual').value=''"><option value="">-- Fetch models first --</option></select>
      <button class="model-refresh-btn" onclick="refreshModels('setup')" title="Refresh model list">&#x1F504;</button>
    </div>
    <input type="text" id="setupModelManual" placeholder="Or type model name manually" value="gpt-4o" oninput="document.getElementById('setupModelSelect').value=''">
    <div class="modal-actions">
      <button class="btn btn-primary" onclick="saveSetup()">Get Started</button>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal">
    <h2>Settings</h2>

    <div class="modal-section">API Configuration</div>
    <label>Base URL</label>
    <input type="text" id="setProxy" placeholder="https://api.openai.com/v1">
    <label>API Key</label>
    <input type="password" id="setKey">
    <label>Model</label>
    <div class="model-selector-row">
      <select id="setModelSelect" onchange="document.getElementById('setModelManual').value=''"><option value="">-- Fetch models first --</option></select>
      <button class="model-refresh-btn" onclick="refreshModels('settings')" title="Refresh model list">&#x1F504;</button>
    </div>
    <input type="text" id="setModelManual" placeholder="Or type model name manually" oninput="document.getElementById('setModelSelect').value=''">
    <label>API Format</label>
    <select id="setApiFormat">
      <option value="auto">Auto-detect</option>
      <option value="openai">OpenAI</option>
      <option value="anthropic">Anthropic</option>
    </select>

    <div class="modal-section">Prompts</div>
    <label>Preset</label>
    <div class="model-selector-row">
      <select id="setPresetSelect" onchange="applyPreset(this.value)">
        <option value="">-- Custom --</option>
      </select>
      <button class="model-refresh-btn" onclick="saveCurrentAsPreset()" title="Save as preset">&#128190;</button>
      <button class="model-refresh-btn" onclick="deleteSelectedPreset()" title="Delete preset">&#128465;</button>
      <button class="model-refresh-btn" onclick="document.getElementById('stPresetFile').click()" title="Import SillyTavern preset">&#128228;</button>
      <input type="file" id="stPresetFile" accept=".json" style="display:none" onchange="importSTPreset(event)">
    </div>
    <label style="display:flex;align-items:center;justify-content:space-between">
      Prompt Entries
      <button class="model-refresh-btn" onclick="addPromptEntry()" title="Add prompt entry">+</button>
    </label>
    <div id="promptEntryList" class="prompt-entry-list"></div>

    <div class="modal-section">Request Parameters</div>
    <label class="toggle-row">
      <input type="checkbox" id="setStreaming" checked> Streaming
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="setEnterSend" checked> Enter sends message
      <span class="toggle-hint">Ctrl+Enter if off</span>
    </label>
    <label>Temperature</label>
    <input type="number" id="setTemperature" step="0.1" min="0" max="2" placeholder="e.g. 0.7 (leave empty for default)">
    <label>Extra Parameters (JSON)</label>
    <textarea id="setExtraParams" placeholder='{"temperature": 0.7, "max_tokens": 4096}'></textarea>
    <label>Exclude Parameters (comma-separated)</label>
    <input type="text" id="setExcludeParams" placeholder="e.g. stream,model">
    <label>Assistant Prefill</label>
    <input type="text" id="setPrefill" placeholder="e.g. Sure! Here's">

    <div class="modal-section">Appearance</div>
    <label>Theme</label>
    <select id="setTheme" onchange="onThemeSelectChange()">
      <optgroup label="Classic">
        <option value="dark">Dark</option>
        <option value="light">Light</option>
        <option value="nord">Nord</option>
        <option value="catppuccin">Catppuccin</option>
        <option value="dracula">Dracula</option>
        <option value="gruvbox">Gruvbox</option>
        <option value="tokyonight">Tokyo Night</option>
        <option value="solarized">Solarized</option>
        <option value="onedark">One Dark</option>
        <option value="rosepine">Rose Pine</option>
        <option value="claude">Claude</option>
        <option value="claudeDark">Claude Dark</option>
      </optgroup>
      <optgroup label="HyDE Gallery">
        <option value="oneBit">1-Bit</option>
        <option value="graphiteMono">Graphite Mono</option>
        <option value="abyssalWave">Abyssal Wave</option>
        <option value="cosmicBlue">Cosmic Blue</option>
        <option value="pixelDream">Pixel Dream</option>
        <option value="anotherWorld">Another World</option>
        <option value="obsidianPurple">Obsidian Purple</option>
        <option value="scarletNight">Scarlet Night</option>
        <option value="synthWave">Synth Wave</option>
        <option value="amethystAura">Amethyst Aura</option>
        <option value="decayGreen">Decay Green</option>
        <option value="greenLush">Green Lush</option>
        <option value="rainDark">Rain Dark</option>
        <option value="everBlushing">Ever Blushing</option>
        <option value="edgeRunner">Edge Runner</option>
        <option value="monokai">Monokai</option>
        <option value="redStone">Red Stone</option>
        <option value="soulsborne">Soulsborne</option>
        <option value="doomBringers">Doom Bringers</option>
        <option value="nightbrew">Nightbrew</option>
        <option value="joker">Joker</option>
        <option value="nordicBlue">Nordic Blue</option>
      </optgroup>
      <option value="custom">Custom</option>
    </select>
    <div class="theme-colors" id="customThemeColors" style="display:none">
      <div class="theme-color-item"><input type="color" id="cBg" oninput="liveCustomTheme()"><span>Background</span></div>
      <div class="theme-color-item"><input type="color" id="cSidebar" oninput="liveCustomTheme()"><span>Sidebar</span></div>
      <div class="theme-color-item"><input type="color" id="cBorder" oninput="liveCustomTheme()"><span>Border</span></div>
      <div class="theme-color-item"><input type="color" id="cText" oninput="liveCustomTheme()"><span>Text</span></div>
      <div class="theme-color-item"><input type="color" id="cTextSec" oninput="liveCustomTheme()"><span>Text Secondary</span></div>
      <div class="theme-color-item"><input type="color" id="cAccent" oninput="liveCustomTheme()"><span>Accent</span></div>
      <div class="theme-color-item"><input type="color" id="cAccentHover" oninput="liveCustomTheme()"><span>Accent Hover</span></div>
      <div class="theme-color-item"><input type="color" id="cMsgUser" oninput="liveCustomTheme()"><span>User Bubble</span></div>
      <div class="theme-color-item"><input type="color" id="cMsgAssistant" oninput="liveCustomTheme()"><span>Assistant Bubble</span></div>
      <div class="theme-color-item"><input type="text" id="cBorderRadius" oninput="liveCustomTheme()" placeholder="16px" style="width:60px"><span>Radius</span></div>
      <div class="theme-color-item"><input type="text" id="cMsgMaxWidth" oninput="liveCustomTheme()" placeholder="75%" style="width:60px"><span>Msg Width</span></div>
      <div class="theme-color-item"><input type="text" id="cMsgFontSize" oninput="liveCustomTheme()" placeholder="0.95em" style="width:60px"><span>Font Size</span></div>
      <div class="theme-color-item"><input type="color" id="cCodeBg" oninput="liveCustomTheme()"><span>Code BG</span></div>
      <div class="theme-color-item" style="grid-column: 1 / -1">
        <button onclick="resetCustomTheme()" style="width:100%;padding:6px;cursor:pointer">Clear custom theme</button>
      </div>
    </div>
    <label>Font</label>
    <input type="text" id="setFont" placeholder="e.g. Inter, Poppins, JetBrains Mono">
    <label>Message Font Size</label>
    <input type="text" id="setMsgFontSize" placeholder="0.95em (default)">
    <label>Message Width</label>
    <input type="text" id="setMsgMaxWidth" placeholder="75% (default)">

    <div class="modal-section">Tools</div>
    <label class="toggle-row">
      <input type="checkbox" id="setWebSearch"> Web Search
      <span class="toggle-hint">Anthropic only</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="setMemory"> Memory
      <span class="toggle-hint">Remember info across chats</span>
    </label>
    <button class="btn btn-secondary" style="width:100%;padding:8px;font-size:0.8em;margin-bottom:14px" onclick="openManageMemories()">Manage Memories</button>

    <div class="modal-section">Cost Tracking</div>
    <label>Input Cost per 1M tokens</label>
    <input type="number" id="setInputCost" step="0.01" placeholder="e.g. 2.50">
    <label>Output Cost per 1M tokens</label>
    <input type="number" id="setOutputCost" step="0.01" placeholder="e.g. 10.00">

    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Modal -->
<div class="modal-overlay" id="shortcutsModal">
  <div class="modal" style="max-width:480px">
    <h2>Keyboard Shortcuts</h2>
    <div style="display:grid;grid-template-columns:auto 1fr;gap:8px 16px;font-size:0.85em">
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Enter</kbd><span>Send message (configurable)</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Shift+Enter</kbd><span>New line in input</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Enter</kbd><span>Always sends message</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+N</kbd><span>New conversation</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+/</kbd><span>Focus input</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+K</kbd><span>Search conversations</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+F</kbd><span>Search in current chat</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Shift+E</kbd><span>Export all conversations</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Escape</kbd><span>Close modal / Stop streaming</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Shift+?</kbd><span>Show this help</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">@model</kbd><span>Override model for one message</span>
    </div>
    <div class="modal-actions" style="margin-top:16px">
      <button class="btn btn-primary" onclick="document.getElementById('shortcutsModal').classList.remove('open')">Close</button>
    </div>
  </div>
</div>

<script>
// ============================================
// State
// ============================================
let conversations = [];
let activeConvId = null;
let messages = [];
let abortController = null;
let streaming = false;
let pendingAttachments = [];
let voiceRec = null;
let modelOverride = null;
let mentionActive = false;
let mentionIdx = 0;

function formatRelativeTime(ts) {
  if (!ts) return '';
  const diff = Date.now() - ts;
  const sec = Math.floor(diff / 1000);
  if (sec < 60) return 'just now';
  const min = Math.floor(sec / 60);
  if (min < 60) return min + 'm ago';
  const hr = Math.floor(min / 60);
  if (hr < 24) return hr + 'h ago';
  const days = Math.floor(hr / 24);
  if (days === 1) return 'Yesterday';
  if (days < 7) return days + 'd ago';
  return new Date(ts).toLocaleDateString();
}

// ============================================
// Toast Notifications
// ============================================
function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => {
    toast.classList.add('removing');
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// ============================================
// Theme Presets
// ============================================
const themePresets = {
  dark:       { bg:'#0a0a0f', sidebar:'#14141a', cardBorder:'rgba(255,255,255,0.08)', textPrimary:'rgba(255,255,255,0.95)', textSecondary:'rgba(255,255,255,0.6)', accent:'#6366f1', accentHover:'#818cf8', msgUser:'#6366f1', msgAssistant:'rgba(255,255,255,0.08)' },
  light:      { bg:'#f5f5f7', sidebar:'#eeeef2', cardBorder:'rgba(0,0,0,0.1)', textPrimary:'rgba(0,0,0,0.9)', textSecondary:'rgba(0,0,0,0.5)', accent:'#6366f1', accentHover:'#818cf8', msgUser:'#6366f1', msgAssistant:'rgba(0,0,0,0.05)' },
  nord:       { bg:'#2e3440', sidebar:'#3b4252', cardBorder:'#434c5e', textPrimary:'#eceff4', textSecondary:'#d8dee9', accent:'#88c0d0', accentHover:'#8fbcbb', msgUser:'#5e81ac', msgAssistant:'#3b4252' },
  catppuccin: { bg:'#1e1e2e', sidebar:'#313244', cardBorder:'#45475a', textPrimary:'#cdd6f4', textSecondary:'#a6adc8', accent:'#cba6f7', accentHover:'#b4befe', msgUser:'#cba6f7', msgAssistant:'#313244' },
  dracula:    { bg:'#282a36', sidebar:'#44475a', cardBorder:'#6272a4', textPrimary:'#f8f8f2', textSecondary:'#bd93f9', accent:'#bd93f9', accentHover:'#ff79c6', msgUser:'#bd93f9', msgAssistant:'#44475a' },
  gruvbox:    { bg:'#282828', sidebar:'#3c3836', cardBorder:'#504945', textPrimary:'#ebdbb2', textSecondary:'#a89984', accent:'#fabd2f', accentHover:'#fe8019', msgUser:'#fabd2f', msgAssistant:'#3c3836' },
  tokyonight: { bg:'#1a1b26', sidebar:'#24283b', cardBorder:'#414868', textPrimary:'#c0caf5', textSecondary:'#565f89', accent:'#7aa2f7', accentHover:'#bb9af7', msgUser:'#7aa2f7', msgAssistant:'#24283b' },
  solarized:  { bg:'#002b36', sidebar:'#073642', cardBorder:'#586e75', textPrimary:'#fdf6e3', textSecondary:'#93a1a1', accent:'#268bd2', accentHover:'#2aa198', msgUser:'#268bd2', msgAssistant:'#073642' },
  onedark:    { bg:'#282c34', sidebar:'#21252b', cardBorder:'#3e4451', textPrimary:'#abb2bf', textSecondary:'#5c6370', accent:'#61afef', accentHover:'#c678dd', msgUser:'#61afef', msgAssistant:'#2c313c' },
  rosepine:   { bg:'#191724', sidebar:'#1f1d2e', cardBorder:'#26233a', textPrimary:'#e0def4', textSecondary:'#908caa', accent:'#c4a7e7', accentHover:'#ebbcba', msgUser:'#c4a7e7', msgAssistant:'#1f1d2e' },
  // HyDE Gallery
  oneBit:         { bg:'#131313', sidebar:'#222222', cardBorder:'#333333', textPrimary:'#e0e0e0', textSecondary:'rgba(224,224,224,0.6)', accent:'#FCFCFC', accentHover:'#ffffff', msgUser:'#FCFCFC', msgAssistant:'#222222' },
  graphiteMono:   { bg:'#222222', sidebar:'#333333', cardBorder:'#444444', textPrimary:'#e0e0e0', textSecondary:'rgba(224,224,224,0.6)', accent:'#D9D9D9', accentHover:'#eeeeee', msgUser:'#D9D9D9', msgAssistant:'#333333' },
  abyssalWave:    { bg:'#061234', sidebar:'#0f1e44', cardBorder:'#182a54', textPrimary:'#d0e0d0', textSecondary:'rgba(208,224,208,0.6)', accent:'#50AA09', accentHover:'#6ec42a', msgUser:'#50AA09', msgAssistant:'#0f1e44' },
  cosmicBlue:     { bg:'#1E212B', sidebar:'#2a2e3a', cardBorder:'#363a48', textPrimary:'#c8cdd2', textSecondary:'rgba(200,205,210,0.6)', accent:'#5B6B76', accentHover:'#7b8b96', msgUser:'#5B6B76', msgAssistant:'#2a2e3a' },
  pixelDream:     { bg:'#1e4c84', sidebar:'#2a5a94', cardBorder:'#3668a4', textPrimary:'#e0f0ff', textSecondary:'rgba(224,240,255,0.6)', accent:'#7ed6ff', accentHover:'#9ee6ff', msgUser:'#7ed6ff', msgAssistant:'#2a5a94' },
  anotherWorld:   { bg:'#0D55B2', sidebar:'#1a64c0', cardBorder:'#2874d0', textPrimary:'#e0f0f8', textSecondary:'rgba(224,240,248,0.6)', accent:'#249CB6', accentHover:'#44bcd6', msgUser:'#249CB6', msgAssistant:'#1a64c0' },
  obsidianPurple: { bg:'#07040C', sidebar:'#16121e', cardBorder:'#251e30', textPrimary:'#e0d8e8', textSecondary:'rgba(224,216,232,0.6)', accent:'#BDA8DC', accentHover:'#ddc8fc', msgUser:'#BDA8DC', msgAssistant:'#16121e' },
  scarletNight:   { bg:'#1E2233', sidebar:'#2a2e44', cardBorder:'#363a54', textPrimary:'#dcd0e0', textSecondary:'rgba(220,208,224,0.6)', accent:'#822195', accentHover:'#a241b5', msgUser:'#822195', msgAssistant:'#2a2e44' },
  synthWave:      { bg:'#495495', sidebar:'#5a64a5', cardBorder:'#6a74b5', textPrimary:'#f0e0f8', textSecondary:'rgba(240,224,248,0.6)', accent:'#ff7edb', accentHover:'#ff9eeb', msgUser:'#ff7edb', msgAssistant:'#5a64a5' },
  amethystAura:   { bg:'#5D69CE', sidebar:'#6d79de', cardBorder:'#7d89ee', textPrimary:'#f0e8f0', textSecondary:'rgba(240,232,240,0.6)', accent:'#A45785', accentHover:'#c477a5', msgUser:'#A45785', msgAssistant:'#6d79de' },
  decayGreen:     { bg:'#14161E', sidebar:'#20222e', cardBorder:'#2c2e3e', textPrimary:'#d8e8e0', textSecondary:'rgba(216,232,224,0.6)', accent:'#95D3AF', accentHover:'#b5f3cf', msgUser:'#95D3AF', msgAssistant:'#20222e' },
  greenLush:      { bg:'#373C3F', sidebar:'#454b4f', cardBorder:'#555b5f', textPrimary:'#d8e8d8', textSecondary:'rgba(216,232,216,0.6)', accent:'#83B38E', accentHover:'#a3d3ae', msgUser:'#83B38E', msgAssistant:'#454b4f' },
  rainDark:       { bg:'#295233', sidebar:'#376243', cardBorder:'#457253', textPrimary:'#d8f0d0', textSecondary:'rgba(216,240,208,0.6)', accent:'#89E574', accentHover:'#a9ff94', msgUser:'#89E574', msgAssistant:'#376243' },
  everBlushing:   { bg:'#141b1e', sidebar:'#20282e', cardBorder:'#2c343e', textPrimary:'#d0e0f0', textSecondary:'rgba(208,224,240,0.6)', accent:'#67b0e8', accentHover:'#87d0ff', msgUser:'#67b0e8', msgAssistant:'#20282e' },
  edgeRunner:     { bg:'#000000', sidebar:'#141414', cardBorder:'#282828', textPrimary:'#e0e0e0', textSecondary:'rgba(224,224,224,0.6)', accent:'#fada16', accentHover:'#ffea46', msgUser:'#fada16', msgAssistant:'#141414' },
  monokai:        { bg:'#2d2a2e', sidebar:'#3d3a3e', cardBorder:'#4d4a4e', textPrimary:'#f8f8f2', textSecondary:'rgba(248,248,242,0.6)', accent:'#f92672', accentHover:'#ff4692', msgUser:'#f92672', msgAssistant:'#3d3a3e' },
  redStone:       { bg:'#161616', sidebar:'#262626', cardBorder:'#363636', textPrimary:'#e8d8e0', textSecondary:'rgba(232,216,224,0.6)', accent:'#EE5396', accentHover:'#ff73b6', msgUser:'#EE5396', msgAssistant:'#262626' },
  soulsborne:     { bg:'#0D0D0D', sidebar:'#1d1d1d', cardBorder:'#2d2d2d', textPrimary:'#e8d8c8', textSecondary:'rgba(232,216,200,0.6)', accent:'#E0701E', accentHover:'#ff903e', msgUser:'#E0701E', msgAssistant:'#1d1d1d' },
  doomBringers:   { bg:'#351810', sidebar:'#452820', cardBorder:'#553830', textPrimary:'#f0e0c8', textSecondary:'rgba(240,224,200,0.6)', accent:'#FABD2F', accentHover:'#ffdd4f', msgUser:'#FABD2F', msgAssistant:'#452820' },
  nightbrew:      { bg:'#821595', sidebar:'#9225a5', cardBorder:'#a235b5', textPrimary:'#e0f0f0', textSecondary:'rgba(224,240,240,0.6)', accent:'#259E9C', accentHover:'#45bebc', msgUser:'#259E9C', msgAssistant:'#9225a5' },
  joker:          { bg:'#4B0082', sidebar:'#5b1092', cardBorder:'#6b20a2', textPrimary:'#d8f8e0', textSecondary:'rgba(216,248,224,0.6)', accent:'#00FF66', accentHover:'#33ff88', msgUser:'#00FF66', msgAssistant:'#5b1092' },
  nordicBlue:     { bg:'#2E3440', sidebar:'#3b4252', cardBorder:'#434c5e', textPrimary:'#eceff4', textSecondary:'#d8dee9', accent:'#88C0D0', accentHover:'#a8e0f0', msgUser:'#88C0D0', msgAssistant:'#3b4252' },
  claude:         { bg:'#FAF9F5', sidebar:'#EBE7DF', cardBorder:'rgba(0,0,0,0.08)', textPrimary:'#1a1915', textSecondary:'rgba(26,25,21,0.55)', accent:'#D97757', accentHover:'#C4684A', msgUser:'#D97757', msgAssistant:'#F3F0E8', borderRadius:'24px', msgMaxWidth:'70%', codeBg:'rgba(0,0,0,0.04)' },
  claudeDark:     { bg:'#1a1915', sidebar:'#1a1915', cardBorder:'rgba(255,255,255,0.08)', textPrimary:'#e8e4db', textSecondary:'rgba(232,228,219,0.5)', accent:'#D97757', accentHover:'#C4684A', msgUser:'#D97757', msgAssistant:'#2b2a27', borderRadius:'24px', msgMaxWidth:'70%', codeBg:'rgba(0,0,0,0.3)' }
};

const themeOrder = ['dark','light','nord','catppuccin','dracula','gruvbox','tokyonight','solarized','onedark','rosepine','oneBit','graphiteMono','abyssalWave','cosmicBlue','pixelDream','anotherWorld','obsidianPurple','scarletNight','synthWave','amethystAura','decayGreen','greenLush','rainDark','everBlushing','edgeRunner','monokai','redStone','soulsborne','doomBringers','nightbrew','joker','nordicBlue','claude','claudeDark'];

// ============================================
// Utility
// ============================================
function isLightColor(color) {
  let hex = color;
  if (hex.startsWith('rgba') || hex.startsWith('rgb')) {
    const m = hex.match(/[\d.]+/g);
    if (m) return (parseFloat(m[0]) * 299 + parseFloat(m[1]) * 587 + parseFloat(m[2]) * 114) / 1000 > 128;
    return false;
  }
  if (hex.startsWith('#')) {
    hex = hex.slice(1);
    if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    const r = parseInt(hex.slice(0,2), 16), g = parseInt(hex.slice(2,4), 16), b = parseInt(hex.slice(4,6), 16);
    return (r * 299 + g * 587 + b * 114) / 1000 > 128;
  }
  return false;
}

// ============================================
// Theme System
// ============================================
function applyTheme(name) {
  let t;
  if (name === 'custom') {
    try { t = JSON.parse(localStorage.getItem('assistantCustomTheme') || 'null'); } catch(e) { console.warn('Custom theme parse error:', e); }
    if (!t) t = themePresets.dark;
  } else {
    t = themePresets[name] || themePresets.dark;
  }
  const s = document.documentElement.style;
  s.setProperty('--bg', t.bg);
  s.setProperty('--sidebar-bg', t.sidebar);
  s.setProperty('--card-border', t.cardBorder);
  s.setProperty('--text-primary', t.textPrimary);
  s.setProperty('--text-secondary', t.textSecondary);
  s.setProperty('--accent', t.accent);
  s.setProperty('--accent-hover', t.accentHover);
  s.setProperty('--msg-user', t.msgUser);
  s.setProperty('--msg-assistant', t.msgAssistant);
  s.setProperty('--hover', isLightColor(t.bg) ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.05)');
  s.setProperty('--accent-text', isLightColor(t.accent) ? '#000000' : '#ffffff');
  s.setProperty('--msg-user-text', isLightColor(t.msgUser) ? '#000000' : '#ffffff');
  const bgLight = isLightColor(t.bg);
  s.setProperty('--overlay-10', bgLight ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)');
  s.setProperty('--overlay-15', bgLight ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.15)');
  s.setProperty('--overlay-25', bgLight ? 'rgba(0,0,0,0.25)' : 'rgba(255,255,255,0.25)');
  s.setProperty('--border-radius', t.borderRadius || '16px');
  s.setProperty('--msg-max-width', t.msgMaxWidth || '75%');
  s.setProperty('--msg-padding', t.msgPadding || '12px 16px');
  s.setProperty('--msg-font-size', t.msgFontSize || '0.95em');
  s.setProperty('--code-bg', t.codeBg || (bgLight ? 'rgba(0,0,0,0.06)' : 'rgba(0,0,0,0.3)'));
  localStorage.setItem('assistantTheme', name);

  const btn = document.getElementById('themeToggle');
  if (btn) {
    btn.innerHTML = isLightColor(t.bg) ? '&#9728;' : '&#9790;';
    btn.title = 'Theme: ' + name;
  }
  applyMsgOverrides();
}

function applyMsgOverrides() {
  const s = document.documentElement.style;
  const fs = localStorage.getItem('assistantMsgFontSize');
  const mw = localStorage.getItem('assistantMsgMaxWidth');
  if (fs) s.setProperty('--msg-font-size', fs);
  if (mw) s.setProperty('--msg-max-width', mw);
}

function toggleTheme() {
  const current = localStorage.getItem('assistantTheme') || 'dark';
  let order = [...themeOrder];
  const hasCustom = localStorage.getItem('assistantCustomTheme');
  if (hasCustom) order.push('custom');
  let idx = order.indexOf(current);
  const next = order[(idx + 1) % order.length];
  applyTheme(next);

  // Flash theme name
  const btn = document.getElementById('themeToggle');
  const old = btn.querySelector('.theme-flash');
  if (old) old.remove();
  const flash = document.createElement('span');
  flash.className = 'theme-flash';
  flash.textContent = next;
  btn.appendChild(flash);
  setTimeout(() => flash.remove(), 1600);
}

function loadTheme() {
  const name = localStorage.getItem('assistantTheme') || 'dark';
  applyTheme(name);
}

// ============================================
// Custom Theme Helpers
// ============================================
function onThemeSelectChange() {
  const val = document.getElementById('setTheme').value;
  document.getElementById('customThemeColors').style.display = val === 'custom' ? 'grid' : 'none';
  if (val === 'custom') {
    loadCustomColorPickers();
  }
  applyTheme(val);
}

function loadCustomColorPickers() {
  let t;
  try { t = JSON.parse(localStorage.getItem('assistantCustomTheme') || 'null'); } catch(e) { console.warn('Custom theme parse error:', e); }
  if (!t) t = themePresets.dark;
  const toHex = (c) => {
    if (c.startsWith('#') && c.length >= 7) return c.slice(0, 7);
    if (c.startsWith('#') && c.length === 4) return '#' + c[1]+c[1]+c[2]+c[2]+c[3]+c[3];
    if (c.startsWith('rgba') || c.startsWith('rgb')) {
      const m = c.match(/[\d.]+/g);
      if (m) return '#' + [m[0],m[1],m[2]].map(v => Math.round(parseFloat(v)).toString(16).padStart(2,'0')).join('');
    }
    return '#000000';
  };
  document.getElementById('cBg').value = toHex(t.bg);
  document.getElementById('cSidebar').value = toHex(t.sidebar);
  document.getElementById('cBorder').value = toHex(t.cardBorder);
  document.getElementById('cText').value = toHex(t.textPrimary);
  document.getElementById('cTextSec').value = toHex(t.textSecondary);
  document.getElementById('cAccent').value = toHex(t.accent);
  document.getElementById('cAccentHover').value = toHex(t.accentHover);
  document.getElementById('cMsgUser').value = toHex(t.msgUser);
  document.getElementById('cMsgAssistant').value = toHex(t.msgAssistant);
  document.getElementById('cBorderRadius').value = t.borderRadius || '';
  document.getElementById('cMsgMaxWidth').value = t.msgMaxWidth || '';
  document.getElementById('cMsgFontSize').value = t.msgFontSize || '';
  document.getElementById('cCodeBg').value = t.codeBg ? toHex(t.codeBg) : '#000000';
}

function resetCustomTheme() {
  localStorage.removeItem('assistantCustomTheme');
  document.getElementById('setTheme').value = 'dark';
  document.getElementById('customThemeColors').style.display = 'none';
  applyTheme('dark');
}

function getCustomThemeFromPickers() {
  const t = {
    bg: document.getElementById('cBg').value,
    sidebar: document.getElementById('cSidebar').value,
    cardBorder: document.getElementById('cBorder').value,
    textPrimary: document.getElementById('cText').value,
    textSecondary: document.getElementById('cTextSec').value,
    accent: document.getElementById('cAccent').value,
    accentHover: document.getElementById('cAccentHover').value,
    msgUser: document.getElementById('cMsgUser').value,
    msgAssistant: document.getElementById('cMsgAssistant').value
  };
  const br = document.getElementById('cBorderRadius').value.trim();
  const mw = document.getElementById('cMsgMaxWidth').value.trim();
  const fs = document.getElementById('cMsgFontSize').value.trim();
  const cb = document.getElementById('cCodeBg').value;
  if (br) t.borderRadius = br;
  if (mw) t.msgMaxWidth = mw;
  if (fs) t.msgFontSize = fs;
  if (cb && cb !== '#000000') t.codeBg = cb;
  return t;
}

function liveCustomTheme() {
  const t = getCustomThemeFromPickers();
  localStorage.setItem('assistantCustomTheme', JSON.stringify(t));
  applyTheme('custom');
}

// ============================================
// Custom Google Fonts
// ============================================
function loadCustomFont(fontName) {
  const old = document.getElementById('customFontLink');
  if (old) old.remove();
  if (!fontName) {
    document.body.style.fontFamily = "'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
    return;
  }
  const link = document.createElement('link');
  link.id = 'customFontLink';
  link.rel = 'stylesheet';
  link.href = 'https://fonts.googleapis.com/css2?family=' + fontName.replace(/ /g, '+') + ':wght@400;500;600;700&display=swap';
  document.head.appendChild(link);
  document.body.style.fontFamily = "'" + fontName + "', 'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
}

// ============================================
// Model Fetching
// ============================================
async function fetchAvailableModels(baseUrl, apiKey) {
  const url = baseUrl.replace(/\/+$/, '') + '/models';
  const resp = await fetch(url, {
    headers: { 'Authorization': 'Bearer ' + apiKey }
  });
  if (!resp.ok) throw new Error('HTTP ' + resp.status);
  const data = await resp.json();
  return data.data?.map(m => m.id) || [];
}

function populateModelSelect(target, models) {
  const select = document.getElementById(target === 'setup' ? 'setupModelSelect' : 'setModelSelect');
  const currentModel = localStorage.getItem('llmModel') || '';
  select.innerHTML = '<option value="">-- Select a model --</option>';
  models.sort().forEach(m => {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = m;
    if (m === currentModel) opt.selected = true;
    select.appendChild(opt);
  });
}

async function refreshModels(target) {
  const proxyInput = document.getElementById(target === 'setup' ? 'setupProxy' : 'setProxy');
  const keyInput = document.getElementById(target === 'setup' ? 'setupKey' : 'setKey');
  let baseUrl = proxyInput.value.trim().replace(/\/(chat\/completions|messages)\/?$/, '');
  const apiKey = keyInput.value.trim();
  if (!baseUrl || !apiKey) { showToast('Enter Base URL and API Key first.', 'error'); return; }
  const btn = event.target;
  btn.textContent = '...';
  btn.disabled = true;
  try {
    const models = await fetchAvailableModels(baseUrl, apiKey);
    localStorage.setItem('llmModelList', JSON.stringify(models));
    populateModelSelect(target, models);
  } catch (e) {
    showToast('Failed to fetch models: ' + e.message, 'error');
  } finally {
    btn.textContent = '\u{1F504}';
    btn.disabled = false;
  }
}

function loadCachedModels(target) {
  try {
    const cached = JSON.parse(localStorage.getItem('llmModelList') || '[]');
    if (cached.length > 0) populateModelSelect(target, cached);
  } catch(e) { console.warn('Cached model list parse error:', e); }
}

// ============================================
// Memory System
// ============================================
async function loadMemories() {
  try {
    const mems = await idbGetAll('memories');
    if (mems.length > 0) return mems;
  } catch(e) {}
  try {
    const mems = JSON.parse(localStorage.getItem('assistantMemories') || '[]');
    if (mems.length > 0) {
      await idbPutAll('memories', mems);
      localStorage.removeItem('assistantMemories');
    }
    return mems;
  } catch(e) { return []; }
}
async function saveMemories(memories) {
  if (!db) return;
  await idbClear('memories');
  await idbPutAll('memories', memories);
}
async function getMemoryPrompt() {
  if (localStorage.getItem('llmMemoryEnabled') !== 'true') return '';
  const memories = await loadMemories();
  if (memories.length === 0) return '';
  return 'User memories (facts learned from previous conversations):\n' +
    memories.map(m => '- ' + m.text).join('\n');
}

async function callApiNonStreaming(messages) {
  const baseUrl = (localStorage.getItem('llmProxyUrl') || '').replace(/\/+$/, '');
  const apiKey = localStorage.getItem('llmApiKey');
  const model = localStorage.getItem('llmModel') || 'gpt-4o';
  const format = detectApiFormat(model);

  let url, headers, body;
  if (format === 'anthropic') {
    url = baseUrl + '/messages';
    headers = { 'Content-Type': 'application/json', 'x-api-key': apiKey, 'anthropic-version': '2023-06-01' };
    const prepared = prepareAnthropicMessages(messages);
    body = { model, system: prepared.system, messages: prepared.messages, max_tokens: 512, stream: false };
  } else {
    url = baseUrl + '/chat/completions';
    headers = { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + apiKey };
    body = { model, messages, stream: false, max_tokens: 512 };
  }

  const resp = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
  if (!resp.ok) throw new Error('HTTP ' + resp.status);
  const data = await resp.json();

  if (format === 'anthropic') {
    return (data.content || []).filter(c => c.type === 'text').map(c => c.text).join('');
  }
  return data.choices?.[0]?.message?.content || '';
}

async function extractMemories(conversationMessages) {
  if (localStorage.getItem('llmMemoryEnabled') !== 'true') return;

  const existing = await loadMemories();
  const existingText = existing.map(m => '- ' + m.text).join('\n') || '(none yet)';

  const extractPrompt = [
    { role: 'system', content: `You are a memory extraction system. Given a conversation, identify important facts about the user worth remembering for future conversations (preferences, personal details, projects, interests, opinions).

Current memories:
${existingText}

Respond ONLY with a JSON array of new memory strings to add. If there's nothing new worth remembering, respond with []. Do not repeat existing memories. Keep each memory concise (1 sentence). Maximum 3 new memories per extraction.

Example response: ["User prefers TypeScript over JavaScript", "User is building a music app"]` },
    ...conversationMessages.filter(m => m.role !== 'system').slice(-10)
  ];

  try {
    const response = await callApiNonStreaming(extractPrompt);
    const newMemories = JSON.parse(response);
    if (Array.isArray(newMemories) && newMemories.length > 0) {
      const memories = await loadMemories();
      newMemories.forEach(text => {
        if (typeof text === 'string' && text.trim()) {
          memories.push({ id: 'mem_' + Date.now() + '_' + Math.random().toString(36).slice(2,5), text: text.trim(), createdAt: Date.now() });
        }
      });
      await saveMemories(memories);
      cleanupMemories(); // fire-and-forget, has its own cooldown
    }
  } catch(e) { /* silent fail  memory is best-effort */ }
}

let _lastCleanup = 0;
async function cleanupMemories() {
  if (Date.now() - _lastCleanup < 300000) return; // 5-min cooldown
  const memories = await loadMemories();
  if (memories.length < 5) return;

  const prompt = [
    { role: 'system', content: `You are a memory cleanup system. Given a list of user memories (each with an ID), identify contradictions and duplicates.

Rules:
- If two memories contradict, keep the NEWER one (higher ID number = newer). Mark the older for removal.
- If two memories say the same thing differently, keep the more specific one. Mark the other for removal.
- If a memory is outdated or superseded, mark it for removal.

Respond ONLY with a JSON object: {"remove": ["id1", "id2"]}
If no changes needed: {"remove": []}` },
    { role: 'user', content: memories.map(m => '[' + m.id + '] ' + m.text).join('\n') }
  ];

  try {
    const response = await callApiNonStreaming(prompt);
    const result = JSON.parse(response);
    if (result.remove && result.remove.length > 0) {
      const cleaned = memories.filter(m => !result.remove.includes(m.id));
      await saveMemories(cleaned);
    }
    _lastCleanup = Date.now();
  } catch(e) { /* silent fail */ }
}

function openManageMemories() {
  document.querySelectorAll('.char-info-overlay,.char-info-popup').forEach(el => el.remove());

  const overlay = document.createElement('div');
  overlay.className = 'char-info-overlay';

  const popup = document.createElement('div');
  popup.className = 'char-info-popup';

  async function renderMemoryList() {
    const memories = await loadMemories();
    let html = '<h3>Memories (' + memories.length + ')</h3>';
    if (memories.length === 0) {
      html += '<div style="color:var(--text-secondary);font-size:0.85em;margin-bottom:12px">No memories saved yet. The AI will automatically remember facts about you as you chat.</div>';
    } else {
      html += '<div style="display:flex;flex-direction:column;gap:6px;margin-bottom:12px">';
      memories.forEach(m => {
        html += '<div style="display:flex;align-items:center;gap:8px;font-size:0.85em;background:var(--hover);padding:8px 10px;border-radius:8px">' +
          '<span style="flex:1;color:var(--text-secondary)">' + m.text.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</span>' +
          '<button onclick="deleteMemory(\'' + m.id + '\')" style="background:none;border:none;color:var(--text-secondary);cursor:pointer;font-size:14px;flex-shrink:0;padding:2px 4px" title="Delete"></button>' +
          '</div>';
      });
      html += '</div>';
      html += '<button class="btn btn-secondary" style="width:100%;margin-bottom:8px;padding:8px;font-size:0.8em" onclick="if(confirm(\'Clear all memories?\')){saveMemories([]).then(()=>openManageMemories())}">Clear All</button>';
    }
    html += '<button class="btn btn-primary" style="width:100%;padding:8px" onclick="this.closest(\'.char-info-popup\').previousElementSibling.click()">Close</button>';
    popup.innerHTML = html;
  }

  overlay.onclick = () => { overlay.remove(); popup.remove(); };
  renderMemoryList();
  document.body.appendChild(overlay);
  document.body.appendChild(popup);
}

async function deleteMemory(id) {
  const memories = (await loadMemories()).filter(m => m.id !== id);
  await saveMemories(memories);
  openManageMemories();
}

// ============================================
// API Format Detection
// ============================================
function detectApiFormat(model) {
  const fmt = localStorage.getItem('llmApiFormat') || 'auto';
  if (fmt !== 'auto') return fmt;
  if (/^claude/i.test(model)) return 'anthropic';
  return 'openai';
}

// ============================================
// Anthropic Message Conversion
// ============================================
function prepareAnthropicMessages(apiMessages) {
  let systemText = '';
  const msgs = [];
  for (const m of apiMessages) {
    if (m.role === 'system') {
      const txt = typeof m.content === 'string' ? m.content : '';
      systemText += (systemText ? '\n\n' : '') + txt;
    } else {
      msgs.push({ role: m.role, content: m.content });
    }
  }
  // Merge consecutive same-role messages
  const merged = [];
  for (const m of msgs) {
    if (merged.length > 0 && merged[merged.length - 1].role === m.role) {
      const prev = merged[merged.length - 1];
      const toArr = (c) => {
        if (Array.isArray(c)) return c;
        if (typeof c === 'string') return [{ type: 'text', text: c }];
        return [{ type: 'text', text: String(c) }];
      };
      prev.content = [...toArr(prev.content), ...toArr(m.content)];
    } else {
      merged.push({ role: m.role, content: m.content });
    }
  }
  // Convert image/file content for Anthropic format
  const converted = merged.map(m => {
    if (Array.isArray(m.content)) {
      const parts = m.content.map(part => {
        if (part.type === 'text') return { type: 'text', text: part.text };
        if (part.type === 'image_url') {
          const url = part.image_url.url;
          if (url.startsWith('data:')) {
            const match = url.match(/^data:(image\/[^;]+);base64,(.+)$/);
            if (match) return { type: 'image', source: { type: 'base64', media_type: match[1], data: match[2] } };
          }
          return { type: 'image', source: { type: 'url', url: url } };
        }
        if (part.type === 'file') {
          const url = part.file.url;
          if (url.startsWith('data:')) {
            const match = url.match(/^data:([^;]+);base64,(.+)$/);
            if (match) return { type: 'document', source: { type: 'base64', media_type: match[1], data: match[2] } };
          }
          return part;
        }
        return part;
      });
      return { role: m.role, content: parts };
    }
    return m;
  });
  return { system: systemText, messages: converted };
}

// ============================================
// Initialization
// ============================================
document.addEventListener('DOMContentLoaded', async () => {
  // Migration: strip endpoint suffix from proxy URL
  const storedUrl = localStorage.getItem('llmProxyUrl');
  if (storedUrl) {
    const cleaned = storedUrl.replace(/\/(chat\/completions|messages)\/?$/, '');
    if (cleaned !== storedUrl) localStorage.setItem('llmProxyUrl', cleaned);
  }

  await openDB();
  migrateToPromptEntries();
  await loadConversations();
  loadTheme();
  loadCustomFont(localStorage.getItem('assistantFont') || '');
  loadCachedModels('setup');
  loadCachedModels('settings');

  // Save on page unload  sync fallback since IDB is async
  window.addEventListener('beforeunload', () => {
    clearTimeout(_saveDebounceTimer);
    saveConversations();
    try {
      localStorage.setItem('assistantConversations', JSON.stringify(conversations));
      localStorage.setItem('assistantActiveConvId', activeConvId || '');
    } catch(e) {}
  });

  // Show setup modal if no API key
  if (!localStorage.getItem('llmProxyUrl') || !localStorage.getItem('llmApiKey')) {
    document.getElementById('setupModal').classList.add('open');
  }

  // Hide voice button if unsupported
  if (!(window.SpeechRecognition || window.webkitSpeechRecognition)) {
    document.getElementById('voiceBtn').style.display = 'none';
  }

  // Auto-resize textarea + character count + @model mentions
  const ta = document.getElementById('chatInput');
  let tokenDebounce;
  ta.addEventListener('input', () => {
    ta.style.height = 'auto';
    ta.style.height = Math.min(ta.scrollHeight, 150) + 'px';
    clearTimeout(tokenDebounce);
    tokenDebounce = setTimeout(updateTokenInfo, 300);
    handleMentionInput(ta);
    updateSendBtnState();
  });

  // Send on Enter (with mention dropdown handling)
  ta.addEventListener('keydown', (e) => {
    if (mentionActive) {
      handleMentionKeydown(e, ta);
      if (e.defaultPrevented) return;
    }
    if (e.key === 'Enter' && !e.shiftKey) {
      const enterSends = localStorage.getItem('llmEnterSend') !== 'false';
      if (enterSends) {
        e.preventDefault();
        sendMessage();
      }
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // Global keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Escape - close modals / stop streaming
    if (e.key === 'Escape') {
      if (document.getElementById('chatSearchBar').classList.contains('open')) {
        closeChatSearch();
        return;
      }
      if (streaming && abortController) { streaming = false; abortController.abort(); }
      document.getElementById('settingsModal').classList.remove('open');
      document.getElementById('setupModal').classList.remove('open');
      document.getElementById('shortcutsModal').classList.remove('open');
    }
    // Ctrl+N - new conversation
    if (e.ctrlKey && e.key === 'n') {
      e.preventDefault();
      createConversation();
    }
    // Ctrl+/ - focus input
    if (e.ctrlKey && e.key === '/') {
      e.preventDefault();
      document.getElementById('chatInput').focus();
    }
    // Ctrl+K - focus sidebar search
    if (e.ctrlKey && e.key === 'k') {
      e.preventDefault();
      const sb = document.getElementById('sidebar');
      if (sb.classList.contains('collapsed')) toggleSidebar();
      document.getElementById('sidebarSearch').focus();
    }
    // Ctrl+Shift+E - export all
    if (e.ctrlKey && e.shiftKey && e.key === 'E') {
      e.preventDefault();
      exportAllConversations();
    }
    // Ctrl+F - chat search
    if (e.ctrlKey && e.key === 'f') {
      e.preventDefault();
      openChatSearch();
    }
    // Ctrl+Shift+? - shortcut help
    if (e.ctrlKey && e.shiftKey && e.key === '?') {
      e.preventDefault();
      document.getElementById('shortcutsModal').classList.add('open');
    }
  });

  // Drag & drop files
  const DOCUMENT_MIMES = ['application/pdf', 'text/plain', 'text/csv', 'text/html', 'text/markdown'];
  const main = document.querySelector('.main');
  main.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
  main.addEventListener('drop', (e) => {
    e.preventDefault();
    Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/') || DOCUMENT_MIMES.includes(f.type)).forEach(readAttachmentFile);
  });

  // Paste images
  ta.addEventListener('paste', (e) => {
    Array.from(e.clipboardData?.items || []).forEach(item => {
      if (item.type.startsWith('image/')) {
        e.preventDefault();
        readAttachmentFile(item.getAsFile());
      }
    });
  });

  // Mobile: collapse sidebar by default
  if (window.innerWidth <= 768) {
    document.getElementById('sidebar').classList.add('collapsed');
  }

  // Scroll-to-bottom FAB
  const msgsArea = document.getElementById('messagesArea');
  const scrollFab = document.getElementById('scrollFab');
  msgsArea.addEventListener('scroll', () => {
    const atBottom = msgsArea.scrollHeight - msgsArea.scrollTop - msgsArea.clientHeight < 100;
    scrollFab.classList.toggle('visible', !atBottom);
  });

  // Initialize mermaid
  if (typeof mermaid !== 'undefined') {
    mermaid.initialize({ startOnLoad: false, theme: 'dark' });
  }
});

// ============================================
// Markdown Renderer
// ============================================
function renderMarkdown(text) {
  if (!text) return '';

  // Fix UTF-8 text that was decoded as Latin-1 (smart quotes, em dashes, etc. showing as  + boxes)
  text = text.replace(/[\xC0-\xF4][\x80-\xBF]{1,3}/g, function(m) {
    try {
      const bytes = new Uint8Array(m.length);
      for (let i = 0; i < m.length; i++) bytes[i] = m.charCodeAt(i);
      return new TextDecoder('utf-8', { fatal: true }).decode(bytes);
    } catch(e) { return m; }
  });

  // Extract KaTeX math before HTML escaping
  const mathPlaceholders = [];
  let s = text;
  // Block math $$...$$
  s = s.replace(/\$\$([\s\S]+?)\$\$/g, (_, math) => {
    const idx = mathPlaceholders.length;
    mathPlaceholders.push({ math, display: true });
    return '\x00MATH' + idx + '\x00';
  });
  // Inline math $...$
  s = s.replace(/\$([^\$\n]+?)\$/g, (_, math) => {
    const idx = mathPlaceholders.length;
    mathPlaceholders.push({ math, display: false });
    return '\x00MATH' + idx + '\x00';
  });

  // Decode HTML entities that models sometimes output before escaping
  s = s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
  s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  // Spoiler tags >!hidden text!<
  s = s.replace(/&gt;!([\s\S]*?)!&lt;/g, '<span class="spoiler" onclick="this.classList.toggle(\'revealed\')">$1</span>');
  // Mermaid code blocks
  s = s.replace(/```mermaid\n([\s\S]*?)```/g, (_, code) =>
    '<div class="mermaid-container"><pre class="mermaid">' + code.trimEnd() + '</pre></div>');
  s = s.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) =>
    '<pre><code' + (lang ? ' class="language-' + lang + '"' : '') + '>' + code.trimEnd() + '</code></pre>');
  s = s.replace(/`([^`\n]+)`/g, '<code>$1</code>');
  s = s.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
  s = s.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  s = s.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  s = s.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  s = s.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em>$1</em>');
  s = s.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');
  s = s.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
  s = s.replace(/((?:<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
  s = s.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  s = s.replace(/^---$/gm, '<hr>');
  // Markdown tables
  s = s.replace(/(^\|.+\|$\n?)+/gm, match => {
    const rows = match.trim().split('\n').filter(r => r.trim());
    if (rows.length < 2) return match;
    const parseRow = r => r.replace(/^\||\|$/g, '').split('|').map(c => c.trim());
    const isSep = r => /^\|[\s\-:|]+\|$/.test(r.trim());
    let headerRow = parseRow(rows[0]);
    let bodyStart = 1;
    if (isSep(rows[1])) bodyStart = 2;
    let html = '<table><thead><tr>' + headerRow.map(c => `<th>${c}</th>`).join('') + '</tr></thead><tbody>';
    for (let i = bodyStart; i < rows.length; i++) {
      if (isSep(rows[i])) continue;
      const cells = parseRow(rows[i]);
      html += '<tr>' + cells.map(c => `<td>${c}</td>`).join('') + '</tr>';
    }
    html += '</tbody></table>';
    return html;
  });
  const parts = s.split(/(<pre>[\s\S]*?<\/pre>|<div class="mermaid-container">[\s\S]*?<\/div>|<table>[\s\S]*?<\/table>)/g);
  s = parts.map(part => (part.startsWith('<pre>') || part.startsWith('<div class="mermaid') || part.startsWith('<table>')) ? part : part.replace(/\n/g, '<br>')).join('');

  // Restore KaTeX math placeholders
  s = s.replace(/\x00MATH(\d+)\x00/g, (_, idx) => {
    const ph = mathPlaceholders[parseInt(idx)];
    if (typeof katex !== 'undefined') {
      try { return katex.renderToString(ph.math, { displayMode: ph.display, throwOnError: false }); } catch(e) { console.warn('KaTeX render error:', e); }
    }
    return (ph.display ? '$$' : '$') + ph.math.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + (ph.display ? '$$' : '$');
  });

  return s;
}

// ============================================
// Code Copy Buttons
// ============================================
function addCodeCopyButtons(container) {
  const langExtMap = { javascript: 'js', js: 'js', typescript: 'ts', ts: 'ts', python: 'py', py: 'py', java: 'java', c: 'c', cpp: 'cpp', csharp: 'cs', cs: 'cs', go: 'go', rust: 'rs', ruby: 'rb', php: 'php', html: 'html', css: 'css', json: 'json', xml: 'xml', yaml: 'yaml', yml: 'yml', sql: 'sql', bash: 'sh', sh: 'sh', shell: 'sh', markdown: 'md', md: 'md', swift: 'swift', kotlin: 'kt', lua: 'lua', r: 'r', perl: 'pl', scala: 'scala', dart: 'dart', zig: 'zig', nim: 'nim', elixir: 'ex', clojure: 'clj', haskell: 'hs', ocaml: 'ml', toml: 'toml', ini: 'ini', dockerfile: 'dockerfile', makefile: 'makefile' };
  container.querySelectorAll('pre').forEach(pre => {
    if (pre.parentElement.classList.contains('code-block-wrapper')) return;
    if (pre.classList.contains('mermaid')) return;
    const wrapper = document.createElement('div');
    wrapper.className = 'code-block-wrapper';
    pre.parentNode.insertBefore(wrapper, pre);
    wrapper.appendChild(pre);
    const btn = document.createElement('button');
    btn.className = 'code-copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = (e) => {
      e.stopPropagation();
      const code = pre.querySelector('code');
      navigator.clipboard.writeText(code ? code.textContent : pre.textContent);
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 2000);
    };
    wrapper.appendChild(btn);
    // Download button
    const code = pre.querySelector('code');
    if (code) {
      const cls = Array.from(code.classList).find(c => c.startsWith('language-'));
      const lang = cls ? cls.replace('language-', '') : '';
      const ext = langExtMap[lang] || lang || 'txt';
      const dlBtn = document.createElement('button');
      dlBtn.className = 'code-download-btn';
      dlBtn.textContent = '\u2913';
      dlBtn.title = 'Download as .' + ext;
      dlBtn.onclick = (e) => {
        e.stopPropagation();
        const blob = new Blob([code.textContent], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'code.' + ext;
        a.click();
        URL.revokeObjectURL(a.href);
      };
      wrapper.appendChild(dlBtn);
    }
  });
}

// ============================================
// Syntax Highlighting
// ============================================
function highlightCodeBlocks(container) {
  if (typeof hljs === 'undefined') return;
  container.querySelectorAll('pre code[class^="language-"]').forEach(el => {
    if (el.dataset.highlighted) return;
    hljs.highlightElement(el);
    el.dataset.highlighted = 'true';
  });
}

// ============================================
// Line Numbers
// ============================================
function addLineNumbers(container) {
  container.querySelectorAll('pre code').forEach(code => {
    if (code.parentElement.classList.contains('has-line-numbers')) return;
    if (code.parentElement.classList.contains('mermaid')) return;
    const lines = code.innerHTML.split('\n');
    if (lines.length < 3) return;
    // Remove trailing empty line if present
    if (lines[lines.length - 1].trim() === '') lines.pop();
    code.innerHTML = lines.map(l => '<span class="code-line">' + l + '</span>').join('\n');
    code.parentElement.classList.add('has-line-numbers');
  });
}

// ============================================
// Mermaid Rendering
// ============================================
let mermaidIdCounter = 0;
async function renderMermaidBlocks(container) {
  if (typeof mermaid === 'undefined') return;
  const pres = container.querySelectorAll('pre.mermaid');
  for (const pre of pres) {
    if (pre.dataset.rendered) continue;
    pre.dataset.rendered = 'true';
    try {
      const id = 'mermaid-' + (mermaidIdCounter++);
      const { svg } = await mermaid.render(id, pre.textContent);
      const div = document.createElement('div');
      div.innerHTML = svg;
      pre.replaceWith(div.firstElementChild);
    } catch (e) {
      pre.textContent = 'Mermaid error: ' + e.message;
    }
  }
}

// ============================================
// Post-Render Pipeline
// ============================================
function postRenderProcessing(bubble) {
  addCodeCopyButtons(bubble);
  highlightCodeBlocks(bubble);
  addLineNumbers(bubble);
  renderMermaidBlocks(bubble);
}

// ============================================
// Token Estimation
// ============================================
function estimateTokens(text) {
  if (!text) return 0;
  return Math.ceil(text.split(/[\s,.!?;:'"()\[\]{}]+/).filter(Boolean).length * 1.3);
}

function getMsgText(msg) {
  if (typeof msg.content === 'string') return msg.content;
  if (Array.isArray(msg.content)) return msg.content.filter(c => c.type === 'text').map(c => c.text).join(' ');
  return '';
}

function updateTokenInfo() {
  const el = document.getElementById('tokenInfo');
  const inputText = document.getElementById('chatInput').value;
  const inputChars = inputText.length;

  const parts = [];
  if (inputChars > 0) {
    const inputTokens = estimateTokens(inputText);
    parts.push(inputChars + ' chars');
    parts.push('~' + (inputTokens > 999 ? (inputTokens / 1000).toFixed(1) + 'k' : inputTokens) + ' tokens');
  }

  let total = 0;
  messages.forEach(m => { total += estimateTokens(getMsgText(m)); });
  if (total > 0 || messages.length > 0) {
    parts.push('Conv: ~' + (total > 999 ? (total / 1000).toFixed(1) + 'k' : total) + ' tokens');
  }

  const inputCost = parseFloat(localStorage.getItem('llmInputCost') || '0');
  const outputCost = parseFloat(localStorage.getItem('llmOutputCost') || '0');
  if ((inputCost > 0 || outputCost > 0) && total > 0) {
    let cost = 0;
    messages.forEach(m => {
      const t = estimateTokens(getMsgText(m));
      cost += t * ((m.role === 'assistant' ? outputCost : inputCost) / 1000000);
    });
    parts.push('~$' + cost.toFixed(4));
  }
  el.textContent = parts.join(' | ');
}

// ============================================
// IndexedDB Storage Layer
// ============================================
const DB_NAME = 'assistantDB';
const DB_VERSION = 1;
let db = null;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('conversations')) d.createObjectStore('conversations', { keyPath: 'id' });
      if (!d.objectStoreNames.contains('memories')) d.createObjectStore('memories', { keyPath: 'id' });
      if (!d.objectStoreNames.contains('meta')) d.createObjectStore('meta', { keyPath: 'key' });
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}

function idbPut(store, data) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const s = tx.objectStore(store);
    s.put(data);
    tx.oncomplete = resolve;
    tx.onerror = () => reject(tx.error);
  });
}

function idbGetAll(store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readonly');
    const s = tx.objectStore(store);
    const req = s.getAll();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function idbDelete(store, key) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const s = tx.objectStore(store);
    s.delete(key);
    tx.oncomplete = resolve;
    tx.onerror = () => reject(tx.error);
  });
}

function idbClear(store) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = resolve;
    tx.onerror = () => reject(tx.error);
  });
}

function idbPutAll(store, items) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(store, 'readwrite');
    const s = tx.objectStore(store);
    items.forEach(item => s.put(item));
    tx.oncomplete = resolve;
    tx.onerror = () => reject(tx.error);
  });
}

// ============================================
// Conversation Management
// ============================================
function genId() { return 'conv_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6); }

function saveConversations() {
  try { localStorage.setItem('assistantActiveConvId', activeConvId || ''); } catch(e) {}
  if (!db) return;
  idbPutAll('conversations', conversations)
    .then(() => idbPut('meta', { key: 'activeConvId', value: activeConvId || '' }))
    .catch(e => console.error('IDB save error:', e));
}

let _saveDebounceTimer;
function debouncedSave() {
  clearTimeout(_saveDebounceTimer);
  _saveDebounceTimer = setTimeout(saveConversations, 1000);
}

async function loadConversations() {
  // Try IndexedDB first
  try {
    const convs = await idbGetAll('conversations');
    if (convs.length > 0) {
      conversations = convs;
      const meta = await new Promise((resolve) => {
        const tx = db.transaction('meta', 'readonly');
        const req = tx.objectStore('meta').get('activeConvId');
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null);
      });
      activeConvId = meta?.value || conversations[0].id;
      conversations.forEach(c => c.messages.forEach(m => {
        if (m.role === 'assistant' && !m.swipes) { m.swipes = [typeof m.content === 'string' ? m.content : '']; m.swipeIndex = 0; }
      }));
      activeConvId = (conversations.find(c => c.id === activeConvId)) ? activeConvId : conversations[0].id;
      messages = getActiveConv().messages;
      renderSidebar();
      renderMessages();
      updateTokenInfo();
      updateCharacterUI();
      return;
    }
  } catch(e) { console.error('IDB load error:', e); }

  // Migrate from localStorage
  const saved = localStorage.getItem('assistantConversations');
  if (saved) {
    try { conversations = JSON.parse(saved); }
    catch (e) { console.error('Failed to parse conversations, resetting:', e); conversations = []; }
  }

  // Migrate legacy
  const legacy = localStorage.getItem('assistantChatHistory');
  if (legacy && conversations.length === 0) {
    try {
      conversations.push({ id: genId(), title: 'Chat', messages: JSON.parse(legacy), createdAt: Date.now(), updatedAt: Date.now() });
      localStorage.removeItem('assistantChatHistory');
    } catch (e) { console.error('Failed to parse legacy chat:', e); }
  }

  if (conversations.length === 0) {
    conversations.push({ id: genId(), title: 'New Chat', messages: [], createdAt: Date.now(), updatedAt: Date.now() });
  }

  // Migrate swipes
  conversations.forEach(c => c.messages.forEach(m => {
    if (m.role === 'assistant' && !m.swipes) { m.swipes = [typeof m.content === 'string' ? m.content : '']; m.swipeIndex = 0; }
  }));

  const savedActive = localStorage.getItem('assistantActiveConvId');
  activeConvId = (savedActive && conversations.find(c => c.id === savedActive)) ? savedActive : conversations[0].id;
  messages = getActiveConv().messages;

  // Write migrated data to IndexedDB and clean localStorage
  try {
    await idbPutAll('conversations', conversations);
    await idbPut('meta', { key: 'activeConvId', value: activeConvId || '' });
    localStorage.removeItem('assistantConversations');
    localStorage.removeItem('assistantActiveConvId');
  } catch(e) { console.error('IDB migration error:', e); }

  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
}

function getActiveConv() { return conversations.find(c => c.id === activeConvId); }

function createConversation() {
  const conv = { id: genId(), title: 'New Chat', messages: [], createdAt: Date.now(), updatedAt: Date.now() };
  conversations.unshift(conv);
  activeConvId = conv.id;
  messages = conv.messages;
  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
  if (window.innerWidth <= 768) toggleSidebar();
}

function switchConversation(id) {
  const conv = conversations.find(c => c.id === id);
  if (!conv) return;
  activeConvId = id;
  messages = conv.messages;
  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
  if (window.innerWidth <= 768) toggleSidebar();
}

function deleteConversation(id, e) {
  e.stopPropagation();
  if (!confirm('Delete this conversation?')) return;
  conversations = conversations.filter(c => c.id !== id);
  if (conversations.length === 0) {
    createConversation();
    return;
  }
  if (activeConvId === id) switchConversation(conversations[0].id);
  saveConversations();
  renderSidebar();
}

function clearAllConversations() {
  if (!confirm('Delete ALL conversations? This cannot be undone.')) return;
  conversations = [];
  createConversation();
}

function renderSidebar() {
  const list = document.getElementById('convList');
  list.innerHTML = '';

  // Sort: pinned first (by updatedAt desc), then unpinned by updatedAt desc
  // If any have sortOrder, use that instead
  const hasSortOrder = conversations.some(c => c.sortOrder != null);
  const sorted = [...conversations].sort((a, b) => {
    if (a.pinned && !b.pinned) return -1;
    if (!a.pinned && b.pinned) return 1;
    if (hasSortOrder && a.sortOrder != null && b.sortOrder != null) return a.sortOrder - b.sortOrder;
    return (b.updatedAt || 0) - (a.updatedAt || 0);
  });

  // Date grouping
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const yesterdayStart = todayStart - 86400000;
  const weekStart = todayStart - 7 * 86400000;
  const monthStart = todayStart - 30 * 86400000;

  function getGroup(c) {
    if (c.pinned) return 'Pinned';
    const t = c.updatedAt || c.createdAt || 0;
    if (t >= todayStart) return 'Today';
    if (t >= yesterdayStart) return 'Yesterday';
    if (t >= weekStart) return 'Last 7 Days';
    if (t >= monthStart) return 'Last 30 Days';
    return 'Older';
  }

  let lastGroup = '';
  sorted.forEach((c, sortIdx) => {
    const group = getGroup(c);
    if (group !== lastGroup) {
      const header = document.createElement('div');
      header.className = 'conv-group-header';
      header.textContent = group;
      header.dataset.group = group;
      list.appendChild(header);
      lastGroup = group;
    }

    const div = document.createElement('div');
    div.className = 'conv-item' + (c.id === activeConvId ? ' active' : '');
    div.onclick = () => switchConversation(c.id);
    div.dataset.convId = c.id;

    // Drag-and-drop (desktop only)
    div.draggable = true;
    div.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', c.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => div.classList.remove('dragging'));
    div.addEventListener('dragover', (e) => { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
    div.addEventListener('drop', (e) => {
      e.preventDefault();
      div.classList.remove('drag-over');
      const draggedId = e.dataTransfer.getData('text/plain');
      if (draggedId === c.id) return;
      const fromIdx = conversations.findIndex(x => x.id === draggedId);
      const toIdx = conversations.findIndex(x => x.id === c.id);
      if (fromIdx === -1 || toIdx === -1) return;
      const [moved] = conversations.splice(fromIdx, 1);
      conversations.splice(toIdx, 0, moved);
      conversations.forEach((x, i) => x.sortOrder = i);
      saveConversations();
      renderSidebar();
    });

    const pinBtn = document.createElement('button');
    pinBtn.className = 'conv-pin' + (c.pinned ? ' pinned' : '');
    pinBtn.innerHTML = '&#128204;';
    pinBtn.title = c.pinned ? 'Unpin' : 'Pin';
    pinBtn.setAttribute('aria-label', c.pinned ? 'Unpin conversation' : 'Pin conversation');
    pinBtn.onclick = (e) => {
      e.stopPropagation();
      c.pinned = !c.pinned;
      saveConversations();
      renderSidebar();
    };

    const title = document.createElement('span');
    title.className = 'conv-title';
    title.textContent = c.title;
    title.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'conv-rename-input';
      input.value = c.title;
      input.onclick = (ev) => ev.stopPropagation();
      const commit = () => {
        const val = input.value.trim();
        if (val && val !== c.title) {
          c.title = val;
          saveConversations();
        }
        renderSidebar();
      };
      input.addEventListener('blur', commit);
      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') commit();
        if (ev.key === 'Escape') renderSidebar();
      });
      title.replaceWith(input);
      input.focus();
      input.select();
    });

    const del = document.createElement('button');
    del.className = 'conv-delete';
    del.innerHTML = '&times;';
    del.title = 'Delete';
    del.setAttribute('aria-label', 'Delete conversation');
    del.onclick = (e) => deleteConversation(c.id, e);

    div.appendChild(pinBtn);
    if (c.characterAvatar) {
      const avatar = document.createElement('img');
      avatar.className = 'conv-avatar';
      avatar.src = c.characterAvatar;
      div.appendChild(avatar);
    }
    div.appendChild(title);
    div.appendChild(del);
    list.appendChild(div);
  });
  filterConversations();
}

// ============================================
// Sidebar Search
// ============================================
function filterConversations() {
  const searchEl = document.getElementById('sidebarSearch');
  const query = searchEl ? searchEl.value.toLowerCase() : '';
  const items = document.querySelectorAll('.conv-item');
  items.forEach(item => {
    const title = item.querySelector('.conv-title').textContent.toLowerCase();
    item.style.display = (!query || title.includes(query)) ? '' : 'none';
  });
  // Hide empty group headers
  document.querySelectorAll('.conv-group-header').forEach(header => {
    let next = header.nextElementSibling;
    let hasVisible = false;
    while (next && !next.classList.contains('conv-group-header')) {
      if (next.classList.contains('conv-item') && next.style.display !== 'none') hasVisible = true;
      next = next.nextElementSibling;
    }
    header.style.display = hasVisible ? '' : 'none';
  });
}

// ============================================
// Sidebar Toggle
// ============================================
function toggleSidebar() {
  const sb = document.getElementById('sidebar');
  const overlay = document.getElementById('sidebarOverlay');
  sb.classList.toggle('collapsed');
  overlay.classList.toggle('open', !sb.classList.contains('collapsed') && window.innerWidth <= 768);
}

// ============================================
// Toolbar Menu
// ============================================
function toggleToolbarMenu(e) {
  e.stopPropagation();
  document.getElementById('toolbarMenu').classList.toggle('open');
}
function closeToolbarMenu() {
  document.getElementById('toolbarMenu').classList.remove('open');
}
document.addEventListener('click', () => closeToolbarMenu());

// ============================================
// Setup & Settings
// ============================================
function getSelectedModel(target) {
  const manualEl = document.getElementById(target === 'setup' ? 'setupModelManual' : 'setModelManual');
  const selectEl = document.getElementById(target === 'setup' ? 'setupModelSelect' : 'setModelSelect');
  const manual = manualEl.value.trim();
  if (manual) return manual;
  return selectEl.value || 'gpt-4o';
}

function saveSetup() {
  let proxy = document.getElementById('setupProxy').value.trim();
  const key = document.getElementById('setupKey').value.trim();
  if (!proxy || !key) { showToast('Base URL and API Key are required.', 'error'); return; }
  proxy = proxy.replace(/\/(chat\/completions|messages)\/?$/, '');
  const model = getSelectedModel('setup');
  localStorage.setItem('llmProxyUrl', proxy);
  localStorage.setItem('llmApiKey', key);
  localStorage.setItem('llmModel', model);
  document.getElementById('setupModal').classList.remove('open');
  // Try to fetch models in the background
  fetchAvailableModels(proxy, key).then(models => {
    localStorage.setItem('llmModelList', JSON.stringify(models));
    loadCachedModels('settings');
  }).catch(() => {});
}

function openSettings() {
  document.getElementById('setProxy').value = localStorage.getItem('llmProxyUrl') || '';
  document.getElementById('setKey').value = localStorage.getItem('llmApiKey') || '';
  const currentModel = localStorage.getItem('llmModel') || '';
  document.getElementById('setModelManual').value = currentModel;
  document.getElementById('setApiFormat').value = localStorage.getItem('llmApiFormat') || 'auto';
  renderPromptEntries();
  document.getElementById('setExtraParams').value = localStorage.getItem('llmExtraParams') || '';
  document.getElementById('setExcludeParams').value = localStorage.getItem('llmExcludeParams') || '';
  document.getElementById('setPrefill').value = localStorage.getItem('llmPrefill') || '';
  document.getElementById('setStreaming').checked = localStorage.getItem('llmStreaming') !== 'false';
  document.getElementById('setEnterSend').checked = localStorage.getItem('llmEnterSend') !== 'false';
  document.getElementById('setTemperature').value = localStorage.getItem('llmTemperature') || '';
  document.getElementById('setInputCost').value = localStorage.getItem('llmInputCost') || '';
  document.getElementById('setOutputCost').value = localStorage.getItem('llmOutputCost') || '';
  document.getElementById('setFont').value = localStorage.getItem('assistantFont') || '';
  document.getElementById('setMsgFontSize').value = localStorage.getItem('assistantMsgFontSize') || '';
  document.getElementById('setMsgMaxWidth').value = localStorage.getItem('assistantMsgMaxWidth') || '';
  document.getElementById('setWebSearch').checked = localStorage.getItem('llmWebSearch') === 'true';
  document.getElementById('setMemory').checked = localStorage.getItem('llmMemoryEnabled') === 'true';

  // Presets
  loadPresets();

  // Theme
  const currentTheme = localStorage.getItem('assistantTheme') || 'dark';
  document.getElementById('setTheme').value = currentTheme;
  document.getElementById('customThemeColors').style.display = currentTheme === 'custom' ? 'grid' : 'none';
  if (currentTheme === 'custom') loadCustomColorPickers();

  // Model select
  loadCachedModels('settings');
  const selectEl = document.getElementById('setModelSelect');
  if (currentModel) {
    for (const opt of selectEl.options) {
      if (opt.value === currentModel) { opt.selected = true; break; }
    }
  }

  document.getElementById('settingsModal').classList.add('open');
}

function saveSettings() {
  // Validate extra params JSON
  const extraParamsField = document.getElementById('setExtraParams');
  const extraParamsVal = extraParamsField.value.trim();
  if (extraParamsVal) {
    try {
      JSON.parse(extraParamsVal);
      extraParamsField.classList.remove('invalid');
    } catch(e) {
      extraParamsField.classList.add('invalid');
      showToast('Extra Parameters must be valid JSON.', 'error');
      return;
    }
  } else {
    extraParamsField.classList.remove('invalid');
  }

  let proxy = document.getElementById('setProxy').value.trim();
  proxy = proxy.replace(/\/(chat\/completions|messages)\/?$/, '');
  localStorage.setItem('llmProxyUrl', proxy);
  localStorage.setItem('llmApiKey', document.getElementById('setKey').value.trim());
  localStorage.setItem('llmModel', getSelectedModel('settings'));
  localStorage.setItem('llmApiFormat', document.getElementById('setApiFormat').value);
  localStorage.setItem('llmExtraParams', extraParamsVal);
  localStorage.setItem('llmExcludeParams', document.getElementById('setExcludeParams').value.trim());
  localStorage.setItem('llmPrefill', document.getElementById('setPrefill').value);
  localStorage.setItem('llmStreaming', document.getElementById('setStreaming').checked ? 'true' : 'false');
  localStorage.setItem('llmEnterSend', document.getElementById('setEnterSend').checked ? 'true' : 'false');
  const tempVal = document.getElementById('setTemperature').value.trim();
  localStorage.setItem('llmTemperature', tempVal);
  localStorage.setItem('llmInputCost', document.getElementById('setInputCost').value.trim());
  localStorage.setItem('llmOutputCost', document.getElementById('setOutputCost').value.trim());
  localStorage.setItem('llmWebSearch', document.getElementById('setWebSearch').checked ? 'true' : 'false');
  localStorage.setItem('llmMemoryEnabled', document.getElementById('setMemory').checked ? 'true' : 'false');

  // Theme
  const themeName = document.getElementById('setTheme').value;
  if (themeName === 'custom') {
    localStorage.setItem('assistantCustomTheme', JSON.stringify(getCustomThemeFromPickers()));
  }
  applyTheme(themeName);

  // Message overrides
  const msgFs = document.getElementById('setMsgFontSize').value.trim();
  const msgMw = document.getElementById('setMsgMaxWidth').value.trim();
  msgFs ? localStorage.setItem('assistantMsgFontSize', msgFs) : localStorage.removeItem('assistantMsgFontSize');
  msgMw ? localStorage.setItem('assistantMsgMaxWidth', msgMw) : localStorage.removeItem('assistantMsgMaxWidth');
  applyMsgOverrides();

  // Font
  const fontName = document.getElementById('setFont').value.trim();
  localStorage.setItem('assistantFont', fontName);
  loadCustomFont(fontName);

  // Try to fetch models in background
  const key = document.getElementById('setKey').value.trim();
  if (proxy && key) {
    fetchAvailableModels(proxy, key).then(models => {
      localStorage.setItem('llmModelList', JSON.stringify(models));
    }).catch(() => {});
  }

  document.getElementById('settingsModal').classList.remove('open');
}

function closeSettings() {
  document.getElementById('settingsModal').classList.remove('open');
  // Revert theme if user didn't save
  loadTheme();
}

// ============================================
// System Prompt Presets
// ============================================
function loadPresets() {
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) { console.warn('Presets parse error:', e); }
  const select = document.getElementById('setPresetSelect');
  select.innerHTML = '<option value="">-- Custom --</option>';
  presets.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.name;
    select.appendChild(opt);
  });
  return presets;
}

function applyPreset(id) {
  if (!id) return;
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) { console.warn('Presets parse error:', e); }
  const preset = presets.find(p => p.id === id);
  if (!preset) return;
  // Prompt entries (new format) or legacy fallback
  if (preset.promptEntries) {
    savePromptEntries(preset.promptEntries);
  } else {
    const entries = [];
    if (preset.systemPrompt) entries.push({ id: 'pe_' + Date.now() + '_sys', name: 'System Prompt', content: preset.systemPrompt, enabled: true });
    if (preset.persona) entries.push({ id: 'pe_' + Date.now() + '_per', name: 'Persona', content: preset.persona, enabled: true });
    if (entries.length > 0) savePromptEntries(entries);
  }
  renderPromptEntries();
  if ('temperature' in preset) document.getElementById('setTemperature').value = preset.temperature ?? '';
  if ('extraParams' in preset) document.getElementById('setExtraParams').value = preset.extraParams || '';
}

function saveCurrentAsPreset() {
  const name = prompt('Preset name:');
  if (!name) return;
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) { console.warn('Presets parse error:', e); }
  const preset = {
    id: 'preset_' + Date.now(),
    name: name,
    promptEntries: loadPromptEntries(),
    temperature: document.getElementById('setTemperature').value.trim(),
    extraParams: document.getElementById('setExtraParams').value.trim()
  };
  presets.push(preset);
  localStorage.setItem('assistantPresets', JSON.stringify(presets));
  loadPresets();
  document.getElementById('setPresetSelect').value = preset.id;
  showToast('Preset saved: ' + name, 'success');
}

function deleteSelectedPreset() {
  const select = document.getElementById('setPresetSelect');
  const id = select.value;
  if (!id) { showToast('Select a preset to delete.', 'info'); return; }
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) { console.warn('Presets parse error:', e); }
  const preset = presets.find(p => p.id === id);
  if (!preset) return;
  if (!confirm('Delete preset "' + preset.name + '"?')) return;
  presets = presets.filter(p => p.id !== id);
  localStorage.setItem('assistantPresets', JSON.stringify(presets));
  loadPresets();

  // Clear imported prompt entries and extra params
  savePromptEntries([{ id: 'pe_' + Date.now() + '_sys', name: 'System Prompt', content: '', enabled: true }]);
  renderPromptEntries();
  document.getElementById('setTemperature').value = '';
  document.getElementById('setExtraParams').value = '';

  showToast('Preset deleted.', 'info');
}

function importSTPreset(event) {
  const file = event.target.files[0];
  if (!file) return;
  event.target.value = '';
  const reader = new FileReader();
  reader.onload = function(e) {
    let data;
    try { data = JSON.parse(e.target.result); } catch(err) {
      showToast('Invalid JSON file.', 'error');
      return;
    }

    // Map ST parameter names to API-compatible names
    const nameMap = {
      temp: 'temperature',
      top_p: 'top_p',
      top_k: 'top_k',
      min_p: 'min_p',
      rep_pen: 'repetition_penalty',
      rep_pen_range: 'repetition_penalty_range',
      rep_pen_slope: 'repetition_penalty_slope',
      freq_pen: 'frequency_penalty',
      presence_pen: 'presence_penalty',
      typical_p: 'typical_p',
      tfs: 'tfs_z',
      top_a: 'top_a',
      mirostat_mode: 'mirostat_mode',
      mirostat_tau: 'mirostat_tau',
      mirostat_eta: 'mirostat_eta',
      max_tokens: 'max_tokens',
      genamt: 'max_tokens',
      max_length: 'max_tokens',
      seed: 'seed',
      smoothing_factor: 'smoothing_factor',
      smoothing_curve: 'smoothing_curve',
      dynatemp: 'dynatemp',
      min_temp: 'min_temp',
      max_temp: 'max_temp',
      temperature_last: 'temperature_last',
      sampler_order: 'sampler_order',
      no_repeat_ngram_size: 'no_repeat_ngram_size',
      penalty_alpha: 'penalty_alpha',
      epsilon_cutoff: 'epsilon_cutoff',
      eta_cutoff: 'eta_cutoff',
      encoder_rep_pen: 'encoder_repetition_penalty',
      frequency_penalty: 'frequency_penalty',
      presence_penalty: 'presence_penalty',
      temperature: 'temperature',
      repetition_penalty: 'repetition_penalty'
    };

    // Fields to skip (metadata, not sampler params)
    const skip = new Set([
      'name', 'preset', 'do_sample', 'early_stopping',
      'grammar_string', 'banned_tokens', 'custom_token_bans',
      'ignore_eos_token_ban', 'num_beams', 'length_penalty',
      'min_length', 'add_bos_token', 'truncation_length',
      'ban_eos_token', 'skip_special_tokens',
      'sampler_priority', 'n'
    ]);

    const extra = {};
    let temperature = null;

    for (const [key, val] of Object.entries(data)) {
      if (skip.has(key)) continue;
      if (typeof val === 'string' && key !== 'sampler_order') continue;
      if (typeof val === 'boolean') continue;
      const mapped = nameMap[key] || key;
      if (mapped === 'temperature') {
        temperature = val;
      } else {
        extra[mapped] = val;
      }
    }

    // Set temperature field
    if (temperature !== null) {
      document.getElementById('setTemperature').value = temperature;
    }

    // Set Extra Parameters field
    document.getElementById('setExtraParams').value = Object.keys(extra).length ? JSON.stringify(extra, null, 2) : '';

    // Extract prompt entries from ST prompts array
    if (Array.isArray(data.prompts)) {
      // Build enabled map from prompt_order (use last order set)
      const enabledMap = {};
      if (Array.isArray(data.prompt_order) && data.prompt_order.length > 0) {
        const orderSet = data.prompt_order[data.prompt_order.length - 1];
        if (orderSet && Array.isArray(orderSet.order)) {
          orderSet.order.forEach(o => { enabledMap[o.identifier] = o.enabled; });
        }
      }

      const entries = [];
      data.prompts.forEach(p => {
        if (p.marker) return; // skip marker-only entries
        if (!p.content || !p.content.trim()) return; // skip empty
        const enabled = enabledMap[p.identifier] != null ? enabledMap[p.identifier] : (p.enabled !== false);
        entries.push({
          id: 'pe_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6),
          name: p.name || p.identifier || 'Untitled',
          content: p.content.trim(),
          enabled: enabled
        });
      });
      if (entries.length > 0) {
        savePromptEntries(entries);
        renderPromptEntries();
      }
    }

    // Save as a named preset
    const presetName = data.name || file.name.replace(/\.json$/i, '');
    let presets = [];
    try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) { console.warn('Presets parse error:', e); }
    const preset = {
      id: 'preset_' + Date.now(),
      name: presetName,
      promptEntries: loadPromptEntries(),
      temperature: temperature !== null ? String(temperature) : '',
      extraParams: document.getElementById('setExtraParams').value.trim()
    };
    presets.push(preset);
    localStorage.setItem('assistantPresets', JSON.stringify(presets));
    loadPresets();
    document.getElementById('setPresetSelect').value = preset.id;
    showToast('Imported ST preset: ' + presetName, 'success');
  };
  reader.readAsText(file);
}

// ============================================
// Prompt Manager
// ============================================
function loadPromptEntries() {
  try { return JSON.parse(localStorage.getItem('llmPromptEntries') || '[]'); } catch(e) { return []; }
}

function savePromptEntries(entries) {
  localStorage.setItem('llmPromptEntries', JSON.stringify(entries));
}

function migrateToPromptEntries() {
  if (localStorage.getItem('llmPromptEntries')) return;
  const entries = [];
  const sys = localStorage.getItem('llmSystemPrompt');
  entries.push({ id: 'pe_' + Date.now() + '_sys', name: 'System Prompt', content: sys || 'You are a helpful assistant.', enabled: true });
  const persona = localStorage.getItem('llmPersona');
  if (persona) {
    entries.push({ id: 'pe_' + Date.now() + '_per', name: 'Persona', content: persona, enabled: true });
  }
  savePromptEntries(entries);
}

function renderPromptEntries() {
  const list = document.getElementById('promptEntryList');
  if (!list) return;
  list.innerHTML = '';
  const entries = loadPromptEntries();

  entries.forEach((entry) => {
    const div = document.createElement('div');
    div.className = 'prompt-entry' + (entry.enabled ? '' : ' disabled');
    div.dataset.peId = entry.id;
    div.draggable = true;

    // Drag-and-drop
    div.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', entry.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => div.classList.remove('dragging'));
    div.addEventListener('dragover', (e) => { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
    div.addEventListener('drop', (e) => {
      e.preventDefault();
      div.classList.remove('drag-over');
      const draggedId = e.dataTransfer.getData('text/plain');
      if (draggedId === entry.id) return;
      const current = loadPromptEntries();
      const fromIdx = current.findIndex(x => x.id === draggedId);
      const toIdx = current.findIndex(x => x.id === entry.id);
      if (fromIdx === -1 || toIdx === -1) return;
      const [moved] = current.splice(fromIdx, 1);
      current.splice(toIdx, 0, moved);
      savePromptEntries(current);
      renderPromptEntries();
    });

    // Header row
    const header = document.createElement('div');
    header.className = 'prompt-entry-header';

    const drag = document.createElement('span');
    drag.className = 'drag-handle';
    drag.textContent = '';

    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.checked = entry.enabled;
    toggle.title = entry.enabled ? 'Enabled' : 'Disabled';
    toggle.onchange = () => togglePromptEntry(entry.id);

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'pe-name';
    nameInput.value = entry.name;
    nameInput.oninput = () => updatePromptEntry(entry.id, 'name', nameInput.value);

    const expandBtn = document.createElement('button');
    expandBtn.textContent = '';
    expandBtn.title = 'Expand/collapse';
    expandBtn.onclick = () => {
      const body = div.querySelector('.prompt-entry-body');
      body.classList.toggle('open');
      expandBtn.textContent = body.classList.contains('open') ? '' : '';
    };

    const delBtn = document.createElement('button');
    delBtn.textContent = '';
    delBtn.title = 'Delete entry';
    delBtn.onclick = () => deletePromptEntry(entry.id);

    header.appendChild(drag);
    header.appendChild(toggle);
    header.appendChild(nameInput);
    header.appendChild(expandBtn);
    header.appendChild(delBtn);

    // Body (collapsible textarea)
    const body = document.createElement('div');
    body.className = 'prompt-entry-body';
    const ta = document.createElement('textarea');
    ta.value = entry.content;
    ta.placeholder = 'Enter prompt content...';
    ta.oninput = () => updatePromptEntry(entry.id, 'content', ta.value);
    body.appendChild(ta);

    div.appendChild(header);
    div.appendChild(body);
    list.appendChild(div);
  });
}

function addPromptEntry() {
  const entries = loadPromptEntries();
  entries.push({ id: 'pe_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6), name: 'New Prompt', content: '', enabled: true });
  savePromptEntries(entries);
  renderPromptEntries();
}

function deletePromptEntry(id) {
  let entries = loadPromptEntries();
  entries = entries.filter(e => e.id !== id);
  savePromptEntries(entries);
  renderPromptEntries();
}

function togglePromptEntry(id) {
  const entries = loadPromptEntries();
  const entry = entries.find(e => e.id === id);
  if (entry) entry.enabled = !entry.enabled;
  savePromptEntries(entries);
  renderPromptEntries();
}

function updatePromptEntry(id, field, value) {
  const entries = loadPromptEntries();
  const entry = entries.find(e => e.id === id);
  if (entry) entry[field] = value;
  savePromptEntries(entries);
}

async function buildSystemMessages(conv) {
  const msgs = [];
  // Character system prompt override takes priority for the first entry
  const hasCharOverride = conv && conv.characterSystemPrompt;
  const entries = loadPromptEntries();
  entries.forEach((entry, i) => {
    if (!entry.enabled) return;
    let content = entry.content;
    // If the conversation has a character system prompt, override the first enabled entry
    if (hasCharOverride && i === 0) content = conv.characterSystemPrompt;
    if (content.trim()) msgs.push({ role: 'system', content });
  });
  // If no entries enabled but character override exists, add it
  if (msgs.length === 0 && hasCharOverride) {
    msgs.push({ role: 'system', content: conv.characterSystemPrompt });
  }
  // Fallback if completely empty
  if (msgs.length === 0) {
    msgs.push({ role: 'system', content: 'You are a helpful assistant.' });
  }
  // Memory prompt
  const mem = await getMemoryPrompt();
  if (mem) msgs.push({ role: 'system', content: mem });
  return msgs;
}

// ============================================
// Render Messages
// ============================================
function maybeAddAvatar(wrapper) {
  const conv = getActiveConv();
  if (conv && conv.characterAvatar) {
    wrapper.classList.add('has-avatar');
    const avatar = document.createElement('img');
    avatar.className = 'msg-avatar';
    avatar.src = conv.characterAvatar;
    avatar.alt = '';
    wrapper.appendChild(avatar);
  }
}

function renderMessages() {
  closeChatSearch();
  const area = document.getElementById('messagesArea');
  area.innerHTML = '';

  if (messages.length === 0) {
    area.innerHTML = '<div class="chat-placeholder">Start a conversation...</div>';
    return;
  }

  messages.forEach((msg, idx) => {
    if (msg._editing) {
      renderEditMode(area, msg, idx);
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'msg-wrapper ' + msg.role;

    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble ' + msg.role;

    if (msg.role === 'user') {
      if (Array.isArray(msg.content)) {
        msg.content.forEach(part => {
          if (part.type === 'text') {
            const sp = document.createElement('span');
            sp.textContent = part.text;
            bubble.appendChild(sp);
          } else if (part.type === 'image_url') {
            const img = document.createElement('img');
            img.src = part.image_url.url;
            img.className = 'chat-inline-img';
            img.alt = 'User uploaded image';
            bubble.appendChild(img);
          } else if (part.type === 'file') {
            const badge = document.createElement('a');
            badge.className = 'chat-file-badge';
            badge.textContent = '\u{1F4C4} ' + (part.file.name || 'file');
            badge.href = part.file.url;
            badge.download = part.file.name || 'file';
            badge.title = 'Download ' + (part.file.name || 'file');
            bubble.appendChild(badge);
          }
        });
      } else {
        bubble.textContent = msg.content;
      }
    } else if (msg.role === 'assistant') {
      const thinkData = msg.swipeThinking && msg.swipeThinking[msg.swipeIndex];
      const toolData = msg.swipeToolUse && msg.swipeToolUse[msg.swipeIndex];
      bubble.innerHTML = renderThinkingHTML(thinkData || '') + renderToolBlocksHTML(toolData || []) + renderMarkdown(msg.content);
      postRenderProcessing(bubble);
    } else {
      bubble.textContent = msg.content;
    }

    if (msg.role === 'assistant') maybeAddAvatar(wrapper);
    wrapper.appendChild(bubble);

    // Message actions
    const actions = document.createElement('div');
    actions.className = 'msg-actions';

    const copyBtn = document.createElement('button');
    copyBtn.className = 'msg-action-btn';
    copyBtn.textContent = 'Copy';
    copyBtn.setAttribute('aria-label', 'Copy message');
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(getMsgText(msg));
      copyBtn.textContent = 'Copied!';
      setTimeout(() => copyBtn.textContent = 'Copy', 1500);
    };
    actions.appendChild(copyBtn);

    if (msg.role === 'user') {
      const editBtn = document.createElement('button');
      editBtn.className = 'msg-action-btn';
      editBtn.textContent = 'Edit';
      editBtn.setAttribute('aria-label', 'Edit message');
      editBtn.onclick = () => { msg._editing = true; renderMessages(); };
      actions.appendChild(editBtn);

      const forkBtn = document.createElement('button');
      forkBtn.className = 'msg-action-btn';
      forkBtn.textContent = 'Fork';
      forkBtn.setAttribute('aria-label', 'Fork conversation');
      forkBtn.onclick = () => forkBranch(idx);
      actions.appendChild(forkBtn);
    }

    const delBtn = document.createElement('button');
    delBtn.className = 'msg-action-btn';
    delBtn.textContent = 'Delete';
    delBtn.setAttribute('aria-label', 'Delete message');
    delBtn.onclick = () => {
      if (msg.role === 'assistant' && !confirm('Delete this response?')) return;
      messages.splice(idx, 1);
      saveConversations();
      renderMessages();
      updateTokenInfo();
    };
    actions.appendChild(delBtn);

    wrapper.appendChild(actions);

    // Message timestamp
    if (msg.timestamp) {
      const tsEl = document.createElement('div');
      tsEl.className = 'msg-timestamp';
      tsEl.textContent = formatRelativeTime(msg.timestamp);
      wrapper.appendChild(tsEl);
    }

    // Branch controls for user messages
    if (msg.role === 'user' && msg.branches && msg.branches.length > 1) {
      const branchDiv = document.createElement('div');
      branchDiv.className = 'branch-controls has-branches';
      const bPrev = document.createElement('button');
      bPrev.textContent = '\u25C0';
      bPrev.disabled = msg.branchIndex <= 0;
      bPrev.onclick = () => switchBranch(idx, -1);
      bPrev.setAttribute('aria-label', 'Previous branch');
      const bCounter = document.createElement('span');
      bCounter.textContent = (msg.branchIndex + 1) + '/' + msg.branches.length;
      const bNext = document.createElement('button');
      bNext.textContent = '\u25B6';
      bNext.disabled = msg.branchIndex >= msg.branches.length - 1;
      bNext.onclick = () => switchBranch(idx, 1);
      bNext.setAttribute('aria-label', 'Next branch');
      branchDiv.appendChild(bPrev);
      branchDiv.appendChild(bCounter);
      branchDiv.appendChild(bNext);
      wrapper.appendChild(branchDiv);
    }

    if (msg.role === 'assistant') {
      // Swipe controls
      const swipeDiv = document.createElement('div');
      swipeDiv.className = 'swipe-controls' + (msg.swipes && msg.swipes.length > 1 ? ' has-swipes' : '');
      const prev = document.createElement('button');
      prev.textContent = '\u25C0';
      prev.disabled = !msg.swipes || msg.swipeIndex <= 0;
      prev.onclick = () => swipeMsg(idx, -1);
      prev.setAttribute('aria-label', 'Previous swipe');
      const counter = document.createElement('span');
      counter.textContent = msg.swipes ? (msg.swipeIndex + 1) + '/' + msg.swipes.length : '1/1';
      const next = document.createElement('button');
      next.textContent = '\u25B6';
      next.disabled = !msg.swipes || msg.swipeIndex >= msg.swipes.length - 1;
      next.onclick = () => swipeMsg(idx, 1);
      next.setAttribute('aria-label', 'Next swipe');
      swipeDiv.appendChild(prev);
      swipeDiv.appendChild(counter);
      swipeDiv.appendChild(next);
      wrapper.appendChild(swipeDiv);

      const regen = document.createElement('button');
      regen.className = 'regen-btn';
      regen.textContent = 'Regenerate';
      regen.setAttribute('aria-label', 'Regenerate response');
      regen.onclick = () => regenerate();

      if (idx === messages.length - 1) {
        const continueBtn = document.createElement('button');
        continueBtn.className = 'regen-btn';
        continueBtn.textContent = 'Continue';
        continueBtn.setAttribute('aria-label', 'Continue generation');
        continueBtn.onclick = () => continueMessage();

        const btnRow = document.createElement('div');
        btnRow.style.cssText = 'display:flex;gap:6px;justify-content:center';
        btnRow.appendChild(regen);
        btnRow.appendChild(continueBtn);
        wrapper.appendChild(btnRow);
      } else {
        wrapper.appendChild(regen);
      }
    }

    // Fade-in on last message only
    if (idx === messages.length - 1) wrapper.classList.add('msg-new');

    area.appendChild(wrapper);
  });

  area.scrollTop = area.scrollHeight;
  updateSendBtnState();
}

function renderEditMode(area, msg, idx) {
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper user';

  const ta = document.createElement('textarea');
  ta.className = 'msg-edit-textarea';
  ta.value = getMsgText(msg);
  wrapper.appendChild(ta);

  if (Array.isArray(msg.content)) {
    const attachments = msg.content.filter(c => c.type === 'image_url' || c.type === 'file');
    if (attachments.length > 0) {
      const attPreview = document.createElement('div');
      attPreview.style.cssText = 'display:flex;gap:8px;flex-wrap:wrap;padding:4px 0';
      attachments.forEach(part => {
        if (part.type === 'image_url') {
          const img = document.createElement('img');
          img.src = part.image_url.url;
          img.className = 'chat-inline-img';
          img.style.cssText = 'max-width:80px;max-height:80px;border-radius:6px;opacity:0.8';
          img.alt = 'Attached image';
          attPreview.appendChild(img);
        } else if (part.type === 'file') {
          const badge = document.createElement('span');
          badge.className = 'chat-file-badge';
          badge.style.opacity = '0.8';
          badge.textContent = '\u{1F4C4} ' + (part.file.name || 'file');
          attPreview.appendChild(badge);
        }
      });
      wrapper.appendChild(attPreview);
    }
  }

  const editActions = document.createElement('div');
  editActions.className = 'msg-edit-actions';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'msg-edit-cancel';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = () => { delete msg._editing; renderMessages(); };

  const saveBtn = document.createElement('button');
  saveBtn.className = 'msg-edit-save';
  saveBtn.textContent = 'Save & Resend';
  saveBtn.onclick = async () => {
    const editedText = ta.value;
    delete msg._editing;

    // Save old branch before truncating (deep clone to prevent mutation)
    const oldBranch = JSON.parse(JSON.stringify(messages.slice(idx)));
    if (!msg.branches) {
      msg.branches = [oldBranch];
    } else {
      msg.branches[msg.branchIndex] = oldBranch;
    }

    if (Array.isArray(msg.content)) {
      const attachments = msg.content.filter(c => c.type === 'image_url' || c.type === 'file');
      if (attachments.length > 0) {
        msg.content = [{ type: 'text', text: editedText }, ...attachments];
      } else {
        msg.content = editedText;
      }
    } else {
      msg.content = editedText;
    }
    messages.length = idx + 1;
    // Create new branch slot and switch to it
    msg.branchIndex = msg.branches.length;
    saveConversations();
    renderMessages();
    await resendAfterEdit();

    // Save new branch (after response)
    const newBranch = JSON.parse(JSON.stringify(messages.slice(idx)));
    msg.branches[msg.branchIndex] = newBranch;
    saveConversations();
    renderMessages();
  };

  editActions.appendChild(cancelBtn);
  editActions.appendChild(saveBtn);
  wrapper.appendChild(editActions);
  area.appendChild(wrapper);
}

async function resendAfterEdit() {
  const proxyUrl = localStorage.getItem('llmProxyUrl');
  const apiKey = localStorage.getItem('llmApiKey');
  const conv = getActiveConv();
  if (!proxyUrl || !apiKey) return;

  const assistantMsg = { role: 'assistant', content: '', swipes: [''], swipeIndex: 0, timestamp: Date.now() };
  messages.push(assistantMsg);

  const area = document.getElementById('messagesArea');
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper assistant';
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble assistant';
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  maybeAddAvatar(wrapper);
  wrapper.appendChild(bubble);
  area.appendChild(wrapper);
  area.scrollTop = area.scrollHeight;

  const apiMessages = await buildSystemMessages(conv);
  messages.forEach(m => { if (m.role !== 'system') apiMessages.push({ role: m.role, content: m.content }); });

  await streamResponse(apiMessages, assistantMsg, 0, bubble);

  extractMemories(apiMessages);
  if (conv) conv.updatedAt = Date.now();
  saveConversations();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Swipe
// ============================================
function swipeMsg(idx, dir) {
  const msg = messages[idx];
  if (!msg || !msg.swipes) return;
  msg.swipeIndex = Math.max(0, Math.min(msg.swipes.length - 1, msg.swipeIndex + dir));
  msg.content = msg.swipes[msg.swipeIndex];
  debouncedSave();
  renderMessages();
}

// ============================================
// Branch Switching
// ============================================
function switchBranch(msgIdx, dir) {
  const msg = messages[msgIdx];
  if (!msg || !msg.branches) return;
  // Save current continuation as the current branch (deep clone)
  msg.branches[msg.branchIndex] = JSON.parse(JSON.stringify(messages.slice(msgIdx)));
  // Switch
  const newIdx = Math.max(0, Math.min(msg.branches.length - 1, msg.branchIndex + dir));
  if (newIdx === msg.branchIndex) return;
  msg.branchIndex = newIdx;
  // Replace messages from msgIdx onward with the selected branch (deep clone)
  const branch = JSON.parse(JSON.stringify(msg.branches[msg.branchIndex]));
  messages.length = msgIdx;
  branch.forEach(m => messages.push(m));
  debouncedSave();
  renderMessages();
  updateTokenInfo();
}

function forkBranch(msgIdx) {
  if (streaming) return;
  const conv = getActiveConv();
  if (!conv) return;

  const forkedMessages = JSON.parse(JSON.stringify(messages.slice(0, msgIdx + 1)));

  const newConv = {
    id: genId(),
    title: conv.title + ' (fork)',
    messages: forkedMessages,
    createdAt: Date.now(),
    updatedAt: Date.now()
  };
  if (conv.characterAvatar) newConv.characterAvatar = conv.characterAvatar;
  if (conv.characterData) newConv.characterData = JSON.parse(JSON.stringify(conv.characterData));

  conversations.unshift(newConv);
  activeConvId = newConv.id;
  messages = newConv.messages;
  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
}

// ============================================
// Thinking/Reasoning Rendering
// ============================================
function renderThinkingHTML(text) {
  if (!text) return '';
  const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return '<div class="thinking-block">' +
    '<div class="thinking-header" onclick="this.nextElementSibling.classList.toggle(\'open\');this.querySelector(\'.thinking-arrow\').textContent=this.nextElementSibling.classList.contains(\'open\')?\'\u25BE\':\'\u25B8\'">' +
    '\uD83D\uDCAD Thinking <span class="thinking-arrow">\u25B8</span></div>' +
    '<div class="thinking-content">' + escaped + '</div></div>';
}

// ============================================
// Tool Use Rendering
// ============================================
function renderToolBlocksHTML(toolBlocks) {
  if (!toolBlocks || toolBlocks.length === 0) return '';
  return toolBlocks.map((tb, i) => {
    const query = tb.query || '';
    const results = tb.results || [];
    const searching = tb.searching;
    if (searching) {
      return '<div class="tool-use-block"><div class="tool-use-header">\u{1F50D} Searching\u2026</div></div>';
    }
    const count = results.length;
    const resultsHTML = results.map(r => {
      const title = r.title || r.url || 'Result';
      const url = r.url || '#';
      const displayUrl = url.replace(/^https?:\/\//, '').replace(/\/+$/, '');
      return '<div class="tool-use-result"><a href="' + url.replace(/"/g, '&quot;') + '" target="_blank" rel="noopener">' +
        title.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</a>' +
        '<span class="tool-result-url">' + displayUrl.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</span></div>';
    }).join('');
    const headerText = '\u{1F50D} Searched "' + query.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;') + '" \u00B7 ' + count + ' result' + (count !== 1 ? 's' : '');
    return '<div class="tool-use-block">' +
      '<div class="tool-use-header" onclick="this.nextElementSibling.classList.toggle(\'open\');this.querySelector(\'.tool-use-arrow\').textContent=this.nextElementSibling.classList.contains(\'open\')?\'\u25BE\':\'\u25B8\'">' +
      headerText +
      ' <span class="tool-use-arrow">\u25B8</span></div>' +
      '<div class="tool-use-results">' + resultsHTML + '</div></div>';
  }).join('');
}

// ============================================
// Streaming
// ============================================
async function streamResponse(apiMessages, assistantMsg, swipeIdx, bubbleEl, overrideModel, prefixText) {
  const baseUrl = (localStorage.getItem('llmProxyUrl') || '').replace(/\/+$/, '');
  const apiKey = localStorage.getItem('llmApiKey');
  const model = overrideModel || localStorage.getItem('llmModel') || 'gpt-4o';
  const format = detectApiFormat(model);

  // Extra params & excludes
  let extra = {};
  try { extra = JSON.parse(localStorage.getItem('llmExtraParams') || '{}'); } catch(e) { console.warn('Extra params parse error:', e); }
  const exclude = (localStorage.getItem('llmExcludeParams') || '').split(',').map(s => s.trim()).filter(Boolean);

  abortController = new AbortController();
  streaming = true;
  const btn = document.getElementById('sendBtn');
  btn.textContent = 'Stop';
  btn.classList.add('streaming');
  btn.disabled = false;

  let fullText = prefixText || '';
  let thinkingText = '';
  let lastRender = 0;
  let toolBlocks = [];
  let currentBlockType = null;
  let inputJsonBuf = '';

  try {
    let url, headers, body;
    const useStream = localStorage.getItem('llmStreaming') !== 'false';

    // Assistant prefill
    const prefill = localStorage.getItem('llmPrefill') || '';
    if (prefill && !prefixText) {
      apiMessages.push({ role: 'assistant', content: prefill });
      fullText = prefill;
    }

    if (format === 'anthropic') {
      url = baseUrl + '/messages';
      headers = {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      };
      const prepared = prepareAnthropicMessages(apiMessages);
      body = { model, system: prepared.system, messages: prepared.messages, max_tokens: 4096, stream: useStream, ...extra };
      if (localStorage.getItem('llmWebSearch') === 'true') {
        body.tools = (body.tools || []).concat([{ type: 'web_search_20250305', name: 'web_search', max_uses: 5 }]);
      }
    } else {
      url = baseUrl + '/chat/completions';
      headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey
      };
      const processedMessages = apiMessages.map(m => {
        if (!Array.isArray(m.content)) return m;
        return {
          ...m,
          content: m.content.map(part => {
            if (part.type === 'image_url' && part.image_url) {
              return { type: 'image_url', image_url: { url: part.image_url.url, detail: 'auto' } };
            }
            if (part.type === 'file') {
              return { type: 'text', text: `[Attached file: ${part.file?.name || 'file'}]` };
            }
            return part;
          })
        };
      });
      body = { model, messages: processedMessages, stream: useStream, ...extra };
    }
    if (!('temperature' in body)) {
      const temp = parseFloat(localStorage.getItem('llmTemperature'));
      if (!isNaN(temp)) body.temperature = temp;
    }
    exclude.forEach(k => delete body[k]);

    const resp = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
      signal: abortController.signal
    });

    if (!resp.ok) {
      let errText = '';
      try { errText = await resp.text(); } catch(e) { console.warn('Error reading response text:', e); }
      throw new Error('API returned ' + resp.status + (errText ? ': ' + errText.slice(0, 200) : ''));
    }

    const ct = resp.headers.get('content-type') || '';

    if (ct.includes('application/json')) {
      const data = await resp.json();
      if (format === 'anthropic') {
        fullText = (data.content || []).filter(c => c.type === 'text').map(c => c.text).join('') || 'No response.';
        // Extract thinking blocks from non-streaming response
        thinkingText = (data.content || []).filter(c => c.type === 'thinking').map(c => c.thinking).join('');
        // Extract tool blocks from non-streaming response
        for (const block of (data.content || [])) {
          if (block.type === 'server_tool_use' && block.name === 'web_search') {
            toolBlocks.push({ query: block.input?.query || '', results: [], searching: false });
          } else if (block.type === 'web_search_tool_result') {
            const tb = toolBlocks[toolBlocks.length - 1] || { query: '', results: [], searching: false };
            if (!toolBlocks.length) toolBlocks.push(tb);
            tb.results = (block.content || []).filter(r => r.type === 'web_search_result').map(r => ({ title: r.title, url: r.url }));
            tb.searching = false;
          }
        }
      } else {
        fullText = data.choices?.[0]?.message?.content || 'No response.';
        thinkingText = data.choices?.[0]?.message?.reasoning_content || '';
      }
      assistantMsg.swipes[swipeIdx] = fullText;
      assistantMsg.content = fullText;
      if (thinkingText) {
        assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
        assistantMsg.swipeThinking[swipeIdx] = thinkingText;
      }
      if (toolBlocks.length > 0) {
        assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
        assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
      }
      bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
      postRenderProcessing(bubbleEl);
    } else {
      // SSE streaming
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          const trimmed = line.trim();

          if (format === 'anthropic') {
            if (!trimmed.startsWith('data:')) continue;
            const payload = trimmed.slice(5).trim();
            if (!payload) continue;
            try {
              const json = JSON.parse(payload);
              if (json.type === 'content_block_start') {
                const cb = json.content_block;
                if (cb && cb.type === 'server_tool_use') {
                  currentBlockType = 'server_tool_use';
                  inputJsonBuf = '';
                  toolBlocks.push({ query: '', results: [], searching: true });
                } else if (cb && cb.type === 'web_search_tool_result') {
                  currentBlockType = 'web_search_tool_result';
                  const tb = toolBlocks[toolBlocks.length - 1];
                  if (tb) {
                    tb.results = (cb.content || []).filter(r => r.type === 'web_search_result').map(r => ({ title: r.title, url: r.url }));
                    tb.searching = false;
                  }
                } else if (cb && cb.type === 'text') {
                  currentBlockType = 'text';
                } else if (cb && cb.type === 'thinking') {
                  currentBlockType = 'thinking';
                }
              } else if (json.type === 'content_block_delta') {
                if (json.delta?.type === 'text_delta' && json.delta?.text) {
                  fullText += json.delta.text;
                } else if (json.delta?.type === 'thinking_delta' && json.delta?.thinking) {
                  thinkingText += json.delta.thinking;
                } else if (json.delta?.type === 'input_json_delta' && json.delta?.partial_json) {
                  inputJsonBuf += json.delta.partial_json;
                }
              } else if (json.type === 'content_block_stop') {
                if (currentBlockType === 'server_tool_use' && inputJsonBuf) {
                  try {
                    const parsed = JSON.parse(inputJsonBuf);
                    const tb = toolBlocks[toolBlocks.length - 1];
                    if (tb && parsed.query) tb.query = parsed.query;
                  } catch(e) {}
                  inputJsonBuf = '';
                }
                currentBlockType = null;
              } else if (json.type === 'message_stop') {
                // done
              } else if (json.type === 'error') {
                throw new Error(json.error?.message || 'Anthropic API error');
              }
            } catch(e) { if (e.message && !e.message.startsWith('Unexpected')) throw e; }
          } else {
            // OpenAI format
            if (!trimmed.startsWith('data:')) continue;
            const payload = trimmed.slice(5).trim();
            if (payload === '[DONE]') continue;
            try {
              const json = JSON.parse(payload);
              const delta = json.choices?.[0]?.delta?.content;
              if (delta) fullText += delta;
              const reasoning = json.choices?.[0]?.delta?.reasoning_content;
              if (reasoning) thinkingText += reasoning;
            } catch(e) {}
          }
        }

        assistantMsg.swipes[swipeIdx] = fullText;
        assistantMsg.content = fullText;
        const now = Date.now();
        if (now - lastRender > 80) {
          // Preserve open/closed state of thinking & tool blocks
          const thinkingOpen = bubbleEl.querySelector('.thinking-content.open') !== null;
          const toolOpen = Array.from(bubbleEl.querySelectorAll('.tool-use-results')).map(el => el.classList.contains('open'));
          bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
          if (thinkingOpen) {
            const tc = bubbleEl.querySelector('.thinking-content');
            const ta = bubbleEl.querySelector('.thinking-arrow');
            if (tc) tc.classList.add('open');
            if (ta) ta.textContent = '\u25BE';
          }
          toolOpen.forEach((open, i) => {
            if (open) {
              const results = bubbleEl.querySelectorAll('.tool-use-results')[i];
              const arrow = bubbleEl.querySelectorAll('.tool-use-arrow')[i];
              if (results) results.classList.add('open');
              if (arrow) arrow.textContent = '\u25BE';
            }
          });
          const msgsArea = document.getElementById('messagesArea');
          const isNearBottom = msgsArea.scrollHeight - msgsArea.scrollTop - msgsArea.clientHeight < 150;
          if (isNearBottom) msgsArea.scrollTop = msgsArea.scrollHeight;
          lastRender = now;
        }
      }
      if (!fullText && !thinkingText) fullText = 'No response.';
      if (thinkingText) {
        assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
        assistantMsg.swipeThinking[swipeIdx] = thinkingText;
      }
      if (toolBlocks.length > 0) {
        assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
        assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
      }
      bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
      postRenderProcessing(bubbleEl);
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      if (!fullText) fullText = '(stopped)';
    } else {
      fullText = 'Error: ' + e.message;
    }
    assistantMsg.swipes[swipeIdx] = fullText;
    assistantMsg.content = fullText;
    if (thinkingText) {
      assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
      assistantMsg.swipeThinking[swipeIdx] = thinkingText;
    }
    if (toolBlocks.length > 0) {
      assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
      assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
    }
    bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
  } finally {
    streaming = false;
    abortController = null;
    btn.classList.remove('streaming');
    btn.disabled = false;
    updateSendBtnState();
  }
}

// ============================================
// Send Button State
// ============================================
function updateSendBtnState() {
  const btn = document.getElementById('sendBtn');
  if (streaming) return;
  const input = document.getElementById('chatInput');
  const hasInput = input.value.trim() || pendingAttachments.length > 0;
  const lastMsg = messages[messages.length - 1];
  if (!hasInput && lastMsg && lastMsg.role === 'user') {
    btn.textContent = 'Regenerate';
  } else {
    btn.textContent = 'Send';
  }
}

// ============================================
// Send Message
// ============================================
async function sendMessage() {
  if (streaming && abortController) { streaming = false; abortController.abort(); return; }

  const input = document.getElementById('chatInput');
  const text = input.value.trim();
  const lastMsg = messages[messages.length - 1];
  const isRegenFromFork = !text && pendingAttachments.length === 0 && lastMsg && lastMsg.role === 'user';
  if (!text && pendingAttachments.length === 0 && !isRegenFromFork) return;

  const proxyUrl = localStorage.getItem('llmProxyUrl');
  const apiKey = localStorage.getItem('llmApiKey');
  const conv = getActiveConv();

  if (!proxyUrl || !apiKey) {
    document.getElementById('setupModal').classList.add('open');
    return;
  }

  if (!isRegenFromFork) {
    let userContent;
    if (pendingAttachments.length > 0) {
      userContent = [];
      if (text) userContent.push({ type: 'text', text });
      pendingAttachments.forEach(att => {
        if (att.type === 'image') {
          userContent.push({ type: 'image_url', image_url: { url: att.dataUrl, detail: 'auto' } });
        } else {
          userContent.push({ type: 'file', file: { url: att.dataUrl, name: att.name, mime: att.mime } });
        }
      });
      pendingAttachments = [];
      document.getElementById('imagePreview').innerHTML = '';
    } else {
      userContent = text;
    }

    messages.push({ role: 'user', content: userContent, timestamp: Date.now() });
    input.value = '';
    input.style.height = 'auto';

    // Auto-title
    if (conv && conv.title === 'New Chat') {
      conv.title = (text || 'Attachment chat').slice(0, 40);
      conv.updatedAt = Date.now();
      renderSidebar();
    }
  }

  renderMessages();

  const assistantMsg = { role: 'assistant', content: '', swipes: [''], swipeIndex: 0, timestamp: Date.now() };
  messages.push(assistantMsg);

  const area = document.getElementById('messagesArea');
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper assistant';
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble assistant';
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  maybeAddAvatar(wrapper);
  wrapper.appendChild(bubble);
  area.appendChild(wrapper);
  area.scrollTop = area.scrollHeight;

  const apiMessages = await buildSystemMessages(conv);
  messages.forEach(m => { if (m.role !== 'system') apiMessages.push({ role: m.role, content: m.content }); });

  // Capture and clear model override
  const overrideModel = modelOverride;
  clearModelOverride();

  await streamResponse(apiMessages, assistantMsg, 0, bubble, overrideModel);

  extractMemories(apiMessages);
  if (conv) conv.updatedAt = Date.now();
  debouncedSave();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Regenerate
// ============================================
async function regenerate() {
  if (streaming) return;
  let lastIdx = -1;
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].role === 'assistant') { lastIdx = i; break; }
  }
  if (lastIdx === -1) return;

  const msg = messages[lastIdx];
  if (!msg.swipes) msg.swipes = [msg.content];
  msg.swipes.push('');
  msg.swipeIndex = msg.swipes.length - 1;
  msg.content = '';
  renderMessages();

  const area = document.getElementById('messagesArea');
  const wrappers = area.querySelectorAll('.msg-wrapper.assistant');
  const lastWrapper = wrappers[wrappers.length - 1];
  const bubble = lastWrapper.querySelector('.msg-bubble');
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';

  const conv = getActiveConv();
  const apiMessages = await buildSystemMessages(conv);
  for (let i = 0; i < lastIdx; i++) {
    if (messages[i].role !== 'system') apiMessages.push({ role: messages[i].role, content: messages[i].content });
  }

  await streamResponse(apiMessages, msg, msg.swipeIndex, bubble);

  if (conv) conv.updatedAt = Date.now();
  debouncedSave();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Continue Message
// ============================================
async function continueMessage() {
  if (streaming) return;
  let lastIdx = -1;
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].role === 'assistant') { lastIdx = i; break; }
  }
  if (lastIdx === -1) return;

  const msg = messages[lastIdx];
  const existingText = typeof msg.content === 'string' ? msg.content : '';
  if (!existingText.trim()) return;

  const conv = getActiveConv();
  const apiMessages = await buildSystemMessages(conv);
  for (let i = 0; i <= lastIdx; i++) {
    if (messages[i].role !== 'system') {
      apiMessages.push({ role: messages[i].role, content: messages[i].content });
    }
  }

  const area = document.getElementById('messagesArea');
  const wrappers = area.querySelectorAll('.msg-wrapper.assistant');
  const lastWrapper = wrappers[wrappers.length - 1];
  const bubble = lastWrapper.querySelector('.msg-bubble');

  await streamResponse(apiMessages, msg, msg.swipeIndex, bubble, null, existingText);

  if (conv) conv.updatedAt = Date.now();
  debouncedSave();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Clear Chat
// ============================================
function clearChat() {
  if (!confirm('Clear this conversation?')) return;
  const conv = getActiveConv();
  if (conv) {
    conv.messages = [];
    conv.title = 'New Chat';
    messages = conv.messages;
    saveConversations();
    renderSidebar();
  }
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Export / Import
// ============================================
function exportConversation() {
  const conv = getActiveConv();
  if (!conv) return;
  const data = { title: conv.title, messages: conv.messages, model: localStorage.getItem('llmModel') || '', systemPrompt: localStorage.getItem('llmSystemPrompt') || '', exportedAt: new Date().toISOString() };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (conv.title || 'chat') + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

function exportAllConversations() {
  const data = {
    conversations: conversations,
    exportedAt: new Date().toISOString(),
    settings: {
      model: localStorage.getItem('llmModel') || '',
      promptEntries: loadPromptEntries(),
      systemPrompt: localStorage.getItem('llmSystemPrompt') || '',
      persona: localStorage.getItem('llmPersona') || '',
      apiFormat: localStorage.getItem('llmApiFormat') || 'auto',
      theme: localStorage.getItem('assistantTheme') || 'dark',
      font: localStorage.getItem('assistantFont') || ''
    }
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'assistant-export-' + new Date().toISOString().slice(0, 10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importConversation(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.messages || !Array.isArray(data.messages)) throw new Error('Invalid format');
      const conv = { id: genId(), title: data.title || 'Imported Chat', messages: data.messages, createdAt: Date.now(), updatedAt: Date.now() };
      conv.messages.forEach(m => {
        if (m.role === 'assistant' && !m.swipes) { m.swipes = [m.content]; m.swipeIndex = 0; }
      });
      conversations.unshift(conv);
      activeConvId = conv.id;
      messages = conv.messages;
      saveConversations();
      renderSidebar();
      renderMessages();
      updateTokenInfo();
    } catch (err) { showToast('Error importing: ' + err.message, 'error'); }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ============================================
// Export as Markdown
// ============================================
function exportMarkdown() {
  const conv = getActiveConv();
  if (!conv || conv.messages.length === 0) { showToast('No messages to export.', 'info'); return; }
  let md = '# ' + conv.title + '\n\n';
  conv.messages.forEach(m => {
    if (m.role === 'user') {
      md += '## User\n\n';
      const text = getMsgText(m);
      if (Array.isArray(m.content)) {
        m.content.forEach(p => {
          if (p.type === 'text') md += p.text + '\n\n';
          else if (p.type === 'image_url') md += '_[Image attachment]_\n\n';
          else if (p.type === 'file') md += '_[File: ' + (p.file.name || 'attachment') + ']_\n\n';
        });
      } else {
        md += text + '\n\n';
      }
    } else if (m.role === 'assistant') {
      md += '## Assistant\n\n' + (m.content || '') + '\n\n';
    }
  });
  const blob = new Blob([md], { type: 'text/markdown' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (conv.title || 'chat') + '.md';
  a.click();
  URL.revokeObjectURL(a.href);
}

// ============================================
// Chat Search (Ctrl+F)
// ============================================
let chatSearchMatches = [];
let chatSearchIdx = -1;
let chatSearchDebounce = null;

function openChatSearch() {
  const bar = document.getElementById('chatSearchBar');
  bar.classList.add('open');
  document.getElementById('chatSearchInput').focus();
}

function closeChatSearch() {
  const bar = document.getElementById('chatSearchBar');
  bar.classList.remove('open');
  document.getElementById('chatSearchInput').value = '';
  document.getElementById('chatSearchCount').textContent = '';
  clearChatHighlights();
  chatSearchMatches = [];
  chatSearchIdx = -1;
}

function clearChatHighlights() {
  document.querySelectorAll('.search-highlight').forEach(el => {
    const parent = el.parentNode;
    parent.replaceChild(document.createTextNode(el.textContent), el);
    parent.normalize();
  });
}

function debouncedChatSearch() {
  clearTimeout(chatSearchDebounce);
  chatSearchDebounce = setTimeout(performChatSearch, 200);
}

function performChatSearch() {
  clearChatHighlights();
  chatSearchMatches = [];
  chatSearchIdx = -1;
  const query = document.getElementById('chatSearchInput').value.trim();
  if (!query) { document.getElementById('chatSearchCount').textContent = ''; return; }

  const area = document.getElementById('messagesArea');
  const walker = document.createTreeWalker(area, NodeFilter.SHOW_TEXT, null, false);
  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  const lowerQuery = query.toLowerCase();
  textNodes.forEach(node => {
    const text = node.textContent;
    const lower = text.toLowerCase();
    let idx = lower.indexOf(lowerQuery);
    if (idx === -1) return;
    const frag = document.createDocumentFragment();
    let lastIdx = 0;
    while (idx !== -1) {
      if (idx > lastIdx) frag.appendChild(document.createTextNode(text.slice(lastIdx, idx)));
      const span = document.createElement('span');
      span.className = 'search-highlight';
      span.textContent = text.slice(idx, idx + query.length);
      frag.appendChild(span);
      chatSearchMatches.push(span);
      lastIdx = idx + query.length;
      idx = lower.indexOf(lowerQuery, lastIdx);
    }
    if (lastIdx < text.length) frag.appendChild(document.createTextNode(text.slice(lastIdx)));
    node.parentNode.replaceChild(frag, node);
  });

  document.getElementById('chatSearchCount').textContent = chatSearchMatches.length + ' matches';
  if (chatSearchMatches.length > 0) {
    chatSearchIdx = 0;
    chatSearchMatches[0].classList.add('active');
    chatSearchMatches[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

function navigateChatSearch(dir) {
  if (chatSearchMatches.length === 0) return;
  chatSearchMatches[chatSearchIdx]?.classList.remove('active');
  chatSearchIdx = (chatSearchIdx + dir + chatSearchMatches.length) % chatSearchMatches.length;
  chatSearchMatches[chatSearchIdx].classList.add('active');
  chatSearchMatches[chatSearchIdx].scrollIntoView({ behavior: 'smooth', block: 'center' });
  document.getElementById('chatSearchCount').textContent = (chatSearchIdx + 1) + '/' + chatSearchMatches.length;
}

// ============================================
// File Attachments
// ============================================
function readAttachmentFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const isImage = file.type.startsWith('image/');
    pendingAttachments.push({ type: isImage ? 'image' : 'file', dataUrl: e.target.result, name: file.name, mime: file.type });
    renderPreviews();
  };
  reader.readAsDataURL(file);
}

function handleFileSelect(event) {
  Array.from(event.target.files).forEach(readAttachmentFile);
  event.target.value = '';
}

function renderPreviews() {
  const container = document.getElementById('imagePreview');
  container.innerHTML = '';
  pendingAttachments.forEach((att, idx) => {
    const thumb = document.createElement('div');
    thumb.className = att.type === 'image' ? 'img-thumb' : 'file-thumb';
    if (att.type === 'image') {
      const imgEl = document.createElement('img');
      imgEl.src = att.dataUrl;
      thumb.appendChild(imgEl);
    } else {
      thumb.textContent = '\u{1F4C4} ' + (att.name || 'file');
    }
    const rm = document.createElement('button');
    rm.className = 'remove-thumb';
    rm.innerHTML = '&times;';
    rm.onclick = () => { pendingAttachments.splice(idx, 1); renderPreviews(); };
    thumb.appendChild(rm);
    container.appendChild(thumb);
  });
}

// ============================================
// @Model Mentions
// ============================================
function clearModelOverride() {
  modelOverride = null;
  document.getElementById('modelOverrideBadge').classList.remove('visible');
}

function setModelOverride(model) {
  modelOverride = model;
  document.getElementById('modelOverrideText').textContent = model;
  document.getElementById('modelOverrideBadge').classList.add('visible');
  closeMentionDropdown();
}

function closeMentionDropdown() {
  document.getElementById('mentionDropdown').classList.remove('open');
  mentionActive = false;
  mentionIdx = 0;
}

function handleMentionInput(ta) {
  const val = ta.value;
  const cursorPos = ta.selectionStart;
  // Find @query before cursor
  const before = val.slice(0, cursorPos);
  const atMatch = before.match(/@([\w\-./]*)$/);
  if (!atMatch) { closeMentionDropdown(); return; }

  const query = atMatch[1].toLowerCase();
  let models = [];
  try { models = JSON.parse(localStorage.getItem('llmModelList') || '[]'); } catch(e) { console.warn('Model list parse error:', e); }
  if (models.length === 0) { closeMentionDropdown(); return; }

  const filtered = models.filter(m => m.toLowerCase().includes(query)).slice(0, 8);
  if (filtered.length === 0) { closeMentionDropdown(); return; }

  const dropdown = document.getElementById('mentionDropdown');
  dropdown.innerHTML = '';
  mentionIdx = 0;
  filtered.forEach((m, i) => {
    const div = document.createElement('div');
    div.className = 'mention-item' + (i === 0 ? ' active' : '');
    div.textContent = m;
    div.onclick = () => selectMention(ta, m, atMatch.index);
    dropdown.appendChild(div);
  });
  dropdown.classList.add('open');
  mentionActive = true;
}

function selectMention(ta, model, atStart) {
  // Remove @query from input
  const after = ta.value.slice(ta.selectionStart);
  ta.value = ta.value.slice(0, atStart) + after;
  ta.focus();
  setModelOverride(model);
}

function handleMentionKeydown(e, ta) {
  if (!mentionActive) return;
  const dropdown = document.getElementById('mentionDropdown');
  const items = dropdown.querySelectorAll('.mention-item');
  if (items.length === 0) return;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    items[mentionIdx]?.classList.remove('active');
    mentionIdx = (mentionIdx + 1) % items.length;
    items[mentionIdx]?.classList.add('active');
    items[mentionIdx]?.scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    items[mentionIdx]?.classList.remove('active');
    mentionIdx = (mentionIdx - 1 + items.length) % items.length;
    items[mentionIdx]?.classList.add('active');
    items[mentionIdx]?.scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter' || e.key === 'Tab') {
    e.preventDefault();
    e.stopPropagation();
    const model = items[mentionIdx]?.textContent;
    if (model) {
      const before = ta.value.slice(0, ta.selectionStart);
      const atMatch = before.match(/@([\w\-./]*)$/);
      if (atMatch) selectMention(ta, model, atMatch.index);
    }
  } else if (e.key === 'Escape') {
    closeMentionDropdown();
  }
}

// ============================================
// Character Card Import (PNG + JSON)
// ============================================
function extractCharaFromPNG(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  let offset = 8; // skip PNG signature
  while (offset < view.byteLength) {
    const len = view.getUint32(offset);
    const typeBytes = new Uint8Array(arrayBuffer, offset + 4, 4);
    const type = String.fromCharCode(...typeBytes);
    if (type === 'tEXt') {
      const data = new Uint8Array(arrayBuffer, offset + 8, len);
      const nullIdx = data.indexOf(0);
      const keyword = new TextDecoder().decode(data.slice(0, nullIdx));
      if (keyword === 'chara') {
        const text = new TextDecoder().decode(data.slice(nullIdx + 1));
        return JSON.parse(atob(text));
      }
    }
    offset += 12 + len; // 4 length + 4 type + data + 4 CRC
  }
  return null;
}

function normalizeCharaCard(raw) {
  // V2 format wraps in { spec, data }
  if (raw.spec === 'chara_card_v2' && raw.data) return raw.data;
  // V1 is flat
  if (raw.name || raw.description || raw.first_mes) return raw;
  return raw;
}

function buildCharaSystemPrompt(card) {
  let parts = [];
  if (card.system_prompt) {
    parts.push(card.system_prompt);
  }
  if (card.name) parts.push('Character: ' + card.name);
  if (card.description) parts.push(card.description);
  if (card.personality) parts.push('Personality: ' + card.personality);
  if (card.scenario) parts.push('Scenario: ' + card.scenario);
  if (card.mes_example) parts.push('Example dialogue:\n' + card.mes_example);
  return parts.join('\n\n');
}

async function importCharacterCard(event) {
  const file = event.target.files[0];
  if (!file) return;
  event.target.value = '';

  try {
    let rawCard = null;
    let avatarDataUrl = null;

    if (file.name.toLowerCase().endsWith('.png')) {
      const arrayBuffer = await file.arrayBuffer();
      rawCard = extractCharaFromPNG(arrayBuffer);
      if (!rawCard) { showToast('No character data found in PNG.', 'error'); return; }
      // Also store the PNG as avatar
      const blob = new Blob([arrayBuffer], { type: 'image/png' });
      avatarDataUrl = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(blob);
      });
    } else if (file.name.toLowerCase().endsWith('.json')) {
      const text = await file.text();
      rawCard = JSON.parse(text);
    } else {
      showToast('Unsupported file type. Use .png or .json.', 'error');
      return;
    }

    const card = normalizeCharaCard(rawCard);
    const charName = card.name || 'Character';
    const systemPrompt = buildCharaSystemPrompt(card);

    // Create a new conversation
    const conv = {
      id: genId(),
      title: charName,
      messages: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
      characterCard: card,
      characterSystemPrompt: systemPrompt
    };

    if (avatarDataUrl) conv.characterAvatar = avatarDataUrl;

    // Add first message if present
    if (card.first_mes) {
      conv.messages.push({
        role: 'assistant',
        content: card.first_mes,
        swipes: [card.first_mes],
        swipeIndex: 0
      });
    }

    conversations.unshift(conv);
    activeConvId = conv.id;
    messages = conv.messages;
    saveConversations();
    renderSidebar();
    renderMessages();
    updateTokenInfo();
    updateCharacterUI();

    showToast('Character imported: ' + charName, 'success');
    if (window.innerWidth <= 768) toggleSidebar();
  } catch (err) {
    showToast('Error importing character: ' + err.message, 'error');
  }
}

function getConversationSystemPrompt(conv) {
  if (conv && conv.characterSystemPrompt) return conv.characterSystemPrompt;
  return localStorage.getItem('llmSystemPrompt') || 'You are a helpful assistant.';
}

function updateCharacterUI() {
  const conv = getActiveConv();
  const infoBtn = document.getElementById('charInfoBtn');
  const titleEl = document.querySelector('.toolbar-title');
  if (conv && conv.characterCard) {
    infoBtn.style.display = '';
    titleEl.textContent = conv.characterCard.name || conv.title;
  } else {
    infoBtn.style.display = 'none';
    titleEl.textContent = 'Synapse';
  }
}

function showCharacterInfo() {
  const conv = getActiveConv();
  if (!conv || !conv.characterCard) return;
  const card = conv.characterCard;

  // Remove existing popup
  document.querySelectorAll('.char-info-overlay,.char-info-popup').forEach(el => el.remove());

  const overlay = document.createElement('div');
  overlay.className = 'char-info-overlay';
  overlay.onclick = () => { overlay.remove(); popup.remove(); };

  const popup = document.createElement('div');
  popup.className = 'char-info-popup';

  let html = '';
  if (conv.characterAvatar) {
    html += '<img class="char-info-avatar" src="' + conv.characterAvatar.replace(/"/g, '&quot;') + '">';
  }
  html += '<h3>' + (card.name || 'Character').replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</h3>';

  const fields = [
    ['Description', card.description],
    ['Personality', card.personality],
    ['Scenario', card.scenario],
    ['First Message', card.first_mes],
    ['System Prompt', card.system_prompt],
    ['Example Dialogue', card.mes_example],
    ['Creator Notes', card.creator_notes]
  ];
  fields.forEach(([label, value]) => {
    if (!value) return;
    html += '<div class="char-info-field"><div class="char-info-label">' + label + '</div>' +
      '<div class="char-info-value">' + value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div></div>';
  });

  html += '<button class="btn btn-primary" style="margin-top:12px;width:100%" onclick="this.parentElement.previousElementSibling.click()">Close</button>';
  popup.innerHTML = html;

  document.body.appendChild(overlay);
  document.body.appendChild(popup);
}

// ============================================
// Voice Input
// ============================================
function toggleVoice() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) return;
  const btn = document.getElementById('voiceBtn');

  if (voiceRec) {
    voiceRec.stop();
    voiceRec = null;
    btn.classList.remove('recording');
    return;
  }

  voiceRec = new SR();
  voiceRec.lang = 'en-US';
  voiceRec.interimResults = true;
  voiceRec.continuous = true;

  const input = document.getElementById('chatInput');
  const startText = input.value;
  btn.classList.add('recording');

  voiceRec.onresult = (e) => {
    let transcript = '';
    for (let i = 0; i < e.results.length; i++) transcript += e.results[i][0].transcript;
    input.value = startText + transcript;
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 150) + 'px';
  };

  voiceRec.onend = () => { btn.classList.remove('recording'); voiceRec = null; };
  voiceRec.onerror = () => { btn.classList.remove('recording'); voiceRec = null; };
  voiceRec.start();
}
</script>
</body>
</html>
